<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Strategy Staaar</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css">
    <script src="https://unpkg.com/@supabase/supabase-js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #ffffff;
            padding: 24px;
            margin: 0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #1e293b;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 40px;
            flex: 1;
            padding: 24px;
            background: #fafbfc;
            border-radius: 20px;
            border: 1px solid #e1e5e9;
            overflow: auto;
            align-items: start;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.06);
        }

        .left-panel-card {
            background: white;
            border-radius: 20px;
            padding: 6px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid #e1e5e9;
            height: fit-content;
        }

        .video-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 28px;
            border: none;
            height: fit-content;
            box-shadow: none;
            position: relative;
            overflow: hidden;
        }

        .video-section h2,
        .video-section h3,
        .video-section p,
        .video-section label {
            color: white !important;
        }

        .video-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            pointer-events: none;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        video {
            width: 100%;
            max-height: 240px;
            object-fit: contain;
            background: #000;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .file-input-wrapper {
            position: relative;
            background: #3b82f6;
            border-radius: 8px;
            overflow: hidden;
            transition: background-color 0.2s;
        }

        .file-input-wrapper:hover {
            background: #2563eb;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-label {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 16px;
            background: #0f172a;
            color: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.15s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            width: 100%;
            text-align: center;
        }

        .file-input-label:hover {
            background: #1e293b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .row-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
            margin-bottom: 12px;
        }

        .row-btn {
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            transition: all 0.15s ease;
            color: #374151;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        .row-btn:hover {
            border-color: #9ca3af;
            background: #f9fafb;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }

        .row-btn.selected {
            background: #0f172a;
            color: white;
            border-color: #0f172a;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.1);
        }

        .screenshot-btn {
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
            padding: 10px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            margin-bottom: 8px;
        }

        .screenshot-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }

        .screenshot-btn:disabled {
            background: #cbd5e1;
            cursor: not-allowed;
            transform: none;
        }

        .map-section {
            background: #f9fafb;
            border-radius: 12px;
            padding: 16px 16px 16px 16px;
            border: 1px solid #f3f4f6;
            height: fit-content;
            overflow-x: auto;
            overflow-y: visible;
            min-width: 1100px;
        }

        .floating-title-card {
            background: white;
            border-radius: 12px;
            padding: 24px 32px;
            margin: 0 auto 24px auto;
            max-width: 600px;
            box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(226, 232, 240, 0.8);
            backdrop-filter: blur(8px);
            text-align: center;
        }

        .main-title {
            font-size: 32px;
            font-weight: 800;
            color: #0f172a;
            margin: 0 0 12px 0;
            letter-spacing: -0.025em;
            line-height: 1.1;
            background: linear-gradient(135deg, #1e293b, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 16px;
            color: #64748b;
            margin: 0;
            font-weight: 600;
            line-height: 1.3;
        }

        .insight-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 6px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            table-layout: fixed;
        }

        .category-cell {
            background: #1e293b;
            color: white;
            font-weight: 700;
            text-align: center;
            padding: 16px 8px;
            border-radius: 10px;
            font-size: 13px;
            width: 130px;
            min-height: 85px;
            vertical-align: middle;
            line-height: 1.2;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            letter-spacing: 0.5px;
        }

        .category-cell.barriers {
            background: linear-gradient(135deg, #0ea5e9, #3b82f6);
        }

        .category-cell.perceptions {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
        }

        .category-cell.goals {
            background: linear-gradient(135deg, #06b6d4, #0891b2);
        }

        .category-cell.drivers {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        .category-cell.mindset {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .image-cell {
            width: 130px;
            height: 100px;
            position: relative;
            padding: 3px;
        }

        .image-placeholder {
            width: 124px;
            height: 94px;
            background: #f8fafc;
            border-radius: 6px;
            border: 2px dashed #cbd5e1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: #94a3b8;
            position: relative;
            overflow: hidden;
            cursor: move;
            transition: all 0.2s;
        }

        .image-placeholder:hover {
            border-color: #3b82f6;
            background: #f8fafc;
        }

        .image-placeholder.has-image {
            border: 2px solid #10b981;
            background: transparent;
        }

        .captured-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 6px;
            position: absolute;
            top: 0;
            left: 0;
            transition: all 0.3s ease;
        }

        .captured-image.fit-complete {
            object-fit: contain;
            background: #f8fafc;
        }

        .image-controls {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 1px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10;
        }

        .image-placeholder:hover .image-controls {
            opacity: 1;
        }

        .image-btn {
            background: rgba(255, 255, 255, 0.95);
            color: #1d1d1f;
            border: 1px solid rgba(0, 0, 0, 0.1);
            padding: 3px;
            font-size: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 16px;
            transition: all 0.15s ease;
        }

        .image-btn:hover {
            background: rgba(29, 29, 31, 0.95);
            color: #f5f5f7;
            border-color: rgba(255, 255, 255, 0.2);
        }

        .image-btn.active {
            background: #1d1d1f;
            color: #f5f5f7;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .image-btn i {
            color: inherit !important;
        }

        .image-btn:hover i {
            color: #f5f5f7 !important;
        }

        .image-btn.active i {
            color: #f5f5f7 !important;
        }

        /* Crop Modal Styles */
        .crop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .crop-modal.show {
            display: flex;
        }

        /* Modern Color Modal Styles */
        .modern-row-btn {
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            text-align: center;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modern-row-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .modern-row-btn.selected {
            transform: translateY(-2px);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3);
        }

        .modern-row-btn .row-name {
            font-size: 11px;
            line-height: 1.2;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Color picker enhancements */
        input[type="color"] {
            -webkit-appearance: none;
            appearance: none;
            border: none;
            cursor: pointer;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 6px;
        }

        /* Button hover effects */
        #cancelColorChanges:hover {
            background: #f8fafc !important;
            border-color: #cbd5e1 !important;
        }

        #applyColorChanges:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%) !important;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .crop-container {
            position: relative;
            max-width: 85vw;
            max-height: 85vh;
            background: #ffffff;
            padding: 24px;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            border: 1px solid #e5e7eb;
        }

        .crop-image {
            max-width: 70vw;
            max-height: 60vh;
            position: relative;
        }

        .crop-quality-controls {
            margin: 15px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
        }

        .quality-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 5px 0;
        }

        .quality-label {
            font-weight: bold;
            min-width: 100px;
            font-size: 12px;
        }

        .quality-slider {
            flex: 1;
            margin: 0 10px;
        }

        .quality-value {
            min-width: 60px;
            font-size: 12px;
            background: white;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .quality-preset {
            margin: 10px 0;
        }

        .preset-btn {
            margin: 2px;
            padding: 8px 16px;
            border: 1px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            color: #475569;
        }

        .preset-btn:hover {
            background: #f8fafc;
            border-color: #3b82f6;
        }

        .preset-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .crop-selector {
            position: absolute;
            border: 3px solid #10b981;
            background: rgba(16, 185, 129, 0.15);
            cursor: move;
            pointer-events: auto;
            /* Fixed 3:2 aspect ratio dimensions */
            width: 240px;
            height: 160px;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .crop-selector::after {
            content: '3:2 Rectangle - Move to Focus Area';
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: #10b981;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
        }

        .crop-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .crop-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nw-resize;
        }

        .crop-handle.ne {
            top: -6px;
            right: -6px;
            cursor: ne-resize;
        }

        .crop-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: sw-resize;
        }

        .crop-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
        }

        .crop-handle.n {
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: n-resize;
        }

        .crop-handle.s {
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            cursor: s-resize;
        }

        .crop-handle.w {
            top: 50%;
            left: -6px;
            transform: translateY(-50%);
            cursor: w-resize;
        }

        .crop-handle.e {
            top: 50%;
            right: -6px;
            transform: translateY(-50%);
            cursor: e-resize;
        }

        .crop-dimensions {
            position: absolute;
            top: -28px;
            left: 0;
            background: rgba(59, 130, 246, 0.95);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
        }

        .crop-controls {
            margin-top: 15px;
            text-align: center;
        }

        .crop-btn {
            margin: 0 6px;
            padding: 10px 20px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.15s ease;
            background: #ffffff;
            color: #374151;
        }

        .crop-btn.confirm {
            background: #1f2937;
            color: #ffffff;
            border-color: #1f2937;
        }

        .crop-btn.confirm:hover {
            background: #111827;
            border-color: #111827;
        }

        .crop-btn.cancel {
            background: #ffffff;
            color: #6b7280;
            border-color: #d1d5db;
        }

        .crop-btn.cancel:hover {
            background: #f9fafb;
            color: #374151;
            border-color: #9ca3af;
        }

        .text-cell {
            background: #ffffff;
            padding: 12px 6px;
            border-radius: 10px;
            font-size: 12px;
            text-align: center;
            font-weight: 600;
            color: #1e293b;
            width: 130px;
            min-height: 85px;
            vertical-align: middle;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
            line-height: 1.2;
            border: 1px solid #e2e8f0;
            transition: all 0.2s;
        }

        .text-cell:hover {
            border-color: #3b82f6;
            background: #f8fafc;
            transform: translateY(-2px);
            box-shadow: 0 8px 16px -4px rgba(0, 0, 0, 0.15);
        }

        .download-section-centered {
            text-align: center;
            margin: 24px 0 0 0;
            padding: 0;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            width: 100%;
        }

        .download-btn {
            background: #0f172a;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
        }

        .download-btn:hover {
            background: #1e293b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .download-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }

        /* Toast Notification Container */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            pointer-events: none;
        }

        .toast {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 16px 20px;
            margin-bottom: 12px;
            max-width: 400px;
            min-width: 300px;
            font-size: 14px;
            font-weight: 500;
            position: relative;
            pointer-events: auto;
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            border-left: 4px solid #10b981;
            color: #065f46;
        }

        .toast.error {
            border-left: 4px solid #ef4444;
            color: #991b1b;
        }

        .toast.info {
            border-left: 4px solid #3b82f6;
            color: #1e40af;
        }

        .toast::before {
            content: '';
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
        }

        .toast-message {
            padding-left: 20px;
            line-height: 1.4;
        }

        .toast-close {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            font-size: 18px;
            color: #9ca3af;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        .toast-close:hover {
            color: #6b7280;
        }

        /* Hide old status element */
        .status {
            display: none;
        }

        /* 3-Step Revenue Generator Styles */
        .revenue-steps {
            max-width: 400px;
            padding: 0;
        }

        .revenue-title {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 12px 0;
            line-height: 1.2;
            text-align: center;
        }

        .step-card {
            background: #ffffff;
            border: 1px solid #e1e5e9;
            border-radius: 12px;
            margin-bottom: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 2px 16px rgba(0, 0, 0, 0.08);
        }

        .step-card:hover {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
            border-color: #667eea;
        }

        .step-header {
            padding: 20px 24px 16px 24px;
            border-bottom: 1px solid #f1f3f5;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            margin-right: 12px;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .step-header h3 {
            display: inline;
            font-size: 15px;
            font-weight: 600;
            color: #1f2937;
            margin: 0 0 6px 0;
            line-height: 1.2;
        }

        .step-description {
            font-size: 13px;
            color: #6b7280;
            margin: 6px 0 0 36px;
            line-height: 1.4;
        }

        .step-subtitle {
            font-size: 14px;
            color: #6b7280;
            margin: 10px 0 0 40px;
            line-height: 1.4;
        }

        .step-content {
            padding: 20px 24px 24px 24px;
        }

        .step-btn {
            width: 100%;
            padding: 14px 20px;
            background: #ffffff;
            border: 1px solid #e1e5e9;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .step-btn:hover {
            background: #f8fafc;
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }

        .step-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.3);
        }

        .step-btn.primary:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }


        .selected-display {
            margin-top: 8px;
            padding: 10px;
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 4px;
        }

        .selected-label {
            font-size: 11px;
            font-weight: 500;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .selected-name {
            font-size: 14px;
            font-weight: 600;
            color: #1f2937;
            margin-bottom: 2px;
        }

        .selected-details {
            font-size: 12px;
            color: #6b7280;
            line-height: 1.4;
        }

        /* Video Container in Step 2 */
        .step-content .video-container {
            margin-bottom: 8px;
            border-radius: 4px;
            overflow: hidden;
        }

        .step-content .video-container video {
            width: 100%;
            height: auto;
            max-height: 160px;
        }

        /* Strategy Selection Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .modal-overlay.show {
            display: flex;
            opacity: 1;
        }

        .modal-container {
            background: white;
            border-radius: 16px;
            width: 90%;
            max-width: 1200px;
            max-height: 90vh;
            overflow: hidden;
            transform: scale(0.95) translateY(20px);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow:
                0 32px 64px -12px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(226, 232, 240, 0.8);
        }

        .modal-overlay.show .modal-container {
            transform: scale(1) translateY(0);
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            color: #6b7280;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.15s ease;
        }

        .modal-close:hover {
            background: #f3f4f6;
            color: #374151;
        }

        .modal-tabs {
            display: flex;
            border-bottom: 1px solid #e5e7eb;
        }

        .tab-btn {
            padding: 12px 24px;
            background: none;
            border: none;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s ease;
        }

        .tab-btn:hover {
            color: #374151;
            background: #f9fafb;
        }

        .tab-btn.active {
            color: #1f2937;
            border-bottom-color: #1f2937;
        }

        .tab-content {
            display: none;
            padding: 24px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        /* Filters Section */
        .filters-section {
            margin-bottom: 24px;
            padding: 16px;
            background: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .filters-section h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        .filter-group {
            margin-bottom: 12px;
        }

        .filter-group label {
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            margin-bottom: 6px;
            display: block;
        }

        .filter-checkboxes {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .filter-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            background: white;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
        }

        .filter-checkbox:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
            transform: translateY(-1px);
        }

        .filter-checkbox input[type="checkbox"] {
            margin: 0;
            opacity: 0;
            position: absolute;
        }

        .filter-checkbox input[type="checkbox"]:checked + i {
            opacity: 1;
        }

        .filter-checkbox input[type="checkbox"]:not(:checked) + i {
            opacity: 0.3;
        }

        .filter-checkbox:has(input:checked) {
            background: #eff6ff;
            border-color: #3b82f6;
            color: #1e40af;
        }

        .filter-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .btn-secondary, .btn-primary {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-secondary {
            background: white;
            border: 1px solid #d1d5db;
            color: #374151;
        }

        .btn-secondary:hover {
            background: #f9fafb;
        }

        .btn-primary {
            background: #1f2937;
            border: 1px solid #1f2937;
            color: white;
        }

        .btn-primary:hover {
            background: #111827;
        }

        /* McKinsey-Style Strategy Cards */
        .strategy-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
            max-height: 70vh;
            overflow-y: auto;
            padding-right: 8px;
        }

        .strategy-card {
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 24px;
            transition: all 0.2s ease;
            cursor: pointer;
            display: flex;
            gap: 24px;
            align-items: stretch;
            min-height: 280px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .strategy-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 16px rgba(59, 130, 246, 0.08);
            background: #fafbff;
        }

        .strategy-card-left {
            flex: 2;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .strategy-card-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 20px;
            min-width: 200px;
            max-width: 250px;
        }

        .strategy-card-header {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .strategy-title-section {
            flex: 1;
            overflow: hidden;
        }

        .strategy-category-badge {
            background: #f3f4f6;
            color: #6b7280;
            font-size: 11px;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .strategy-value-prop {
            margin-bottom: 12px;
            background: #f8fafc;
            padding: 8px;
            border-radius: 6px;
            border-left: 3px solid #3b82f6;
        }

        .strategy-who, .strategy-value, .strategy-need {
            margin: 0 0 4px 0;
            font-size: 11px;
            line-height: 1.4;
        }

        .strategy-who:last-child, .strategy-value:last-child, .strategy-need:last-child {
            margin-bottom: 0;
        }

        .strategy-target {
            font-size: 11px;
            color: #6b7280;
            margin: 8px 0;
            font-weight: normal;
        }

        .strategy-card-title {
            font-size: 20px;
            font-weight: 700;
            color: #111827;
            margin: 0 0 6px 0;
            line-height: 1.3;
            letter-spacing: -0.025em;
            word-wrap: break-word;
        }

        .strategy-card-description {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
            line-height: 1.4;
            word-wrap: break-word;
        }

        .strategy-value-section {
            display: flex;
            flex-direction: column;
            gap: 16px;
            flex: 1;
        }

        .strategy-value-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .strategy-value-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .strategy-value-text {
            font-size: 14px;
            color: #6b7280;
            line-height: 1.4;
            margin-left: 20px;
            word-wrap: break-word;
        }

        .strategy-card-tags {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: stretch;
        }

        .strategy-tag {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            gap: 4px;
            white-space: nowrap;
            text-align: center;
        }

        .strategy-tag.price {
            background: #ecfdf5;
            color: #065f46;
        }

        .strategy-tag.time {
            background: #eff6ff;
            color: #1e40af;
        }

        .strategy-tag.urgency {
            background: #fef2f2;
            color: #dc2626;
        }

        .strategy-select-btn {
            padding: 10px 16px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            text-align: center;
            width: 100%;
            margin-top: auto;
        }

        .strategy-select-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        /* Custom scrollbar for strategy grid */
        .strategy-grid::-webkit-scrollbar {
            width: 6px;
        }

        .strategy-grid::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }

        .strategy-grid::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .strategy-grid::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* Custom Strategy Section */
        .custom-strategy-section h3 {
            margin: 0 0 8px 0;
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
        }

        .format-hint {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 16px;
            line-height: 1.4;
        }

        #csvInput {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-family: monospace;
            font-size: 11px;
            resize: vertical;
            margin-bottom: 12px;
        }

        .csv-info {
            margin-bottom: 16px;
        }

        .csv-info p {
            font-size: 11px;
            color: #6b7280;
            margin: 0;
        }

        .csv-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Row Selector in Step 2 */
        .step-content .row-selector {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 4px;
            margin-top: 6px;
        }

        .step-content .row-btn {
            padding: 6px 8px;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 500;
            color: #374151;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .step-content .row-btn:hover {
            background: #f3f4f6;
            border-color: #9ca3af;
        }

        .step-content .row-btn.active {
            background: #1f2937;
            color: white;
            border-color: #1f2937;
        }

        .row-highlight {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
            border-radius: 8px;
        }

        .color-row-btn {
            padding: 10px 14px;
            border: 1px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            color: #475569;
        }

        .color-row-btn:hover {
            border-color: #3b82f6;
            background: #f8fafc;
        }

        .color-row-btn.selected {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }


        #mapPreview .insight-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 8px;
            font-size: 10px;
        }

        #mapPreview .category-cell {
            padding: 10px;
            font-size: 11px;
        }

        #mapPreview .text-cell {
            padding: 6px;
            font-size: 9px;
            line-height: 1.1;
        }

        #mapPreview .image-cell {
            width: 120px;
            height: 90px;
        }

        #mapPreview .image-placeholder {
            width: 116px;
            height: 86px;
        }

        .video-container.watermarked::after {
            content: "DEMO VERSION";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: rotate(-45deg);
            color: rgba(255, 255, 255, 0.4);
            font-size: 16px;
            pointer-events: none;
            z-index: 5;
        }

        /* Constant green connection styling for all rows */
        .connected-pair {
            border: 3px solid #10b981 !important;
            background-color: rgba(16, 185, 129, 0.08);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.15);
            transition: all 0.2s ease;
        }

        .connection-arrow {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, #10b981, #34d399);
            top: 50%;
            transform: translateY(-50%);
            z-index: 5;
            border-radius: 3px;
            box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
            animation: connectionPulse 2s ease-in-out infinite;
        }

        @keyframes connectionPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .connection-arrow::after {
            content: '';
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid #10b981;
            border-top: 7px solid transparent;
            border-bottom: 7px solid transparent;
        }

        /* Constant green arrow styling for all rows */

        .insight-table {
            position: relative;
        }

        /* Bootstrap Icons Integration Styles */
        .text-cell i {
            transition: color 0.2s ease;
        }

        .text-cell:hover i {
            color: #3b82f6;
        }

        .connected-pair i {
            color: #10b981 !important;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }


        /* Icon Picker Modal Styles */
        .text-cell.icon-customizable {
            cursor: pointer;
            border: 2px dashed transparent;
            transition: border-color 0.2s;
        }

        .text-cell.icon-customizable:hover {
            border-color: #2196F3;
        }

        .icon-picker-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            margin: 15px 0;
        }

        .icon-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
        }

        .icon-option:hover {
            background: #e3f2fd;
            border-color: #2196F3;
        }

        .icon-option.selected {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }



        /* Header Section Styles */
        .modern-header {
            background: #ffffff;
            border-bottom: 1px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 50;
            padding: 20px 24px;
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo {
            font-size: 24px;
            font-weight: 700;
            color: #0f172a;
            margin: 0;
            letter-spacing: -0.025em;
        }

        .logo-tagline {
            background: #f3f4f6;
            color: #6b7280;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .header-nav {
            display: flex;
            gap: 32px;
            align-items: center;
        }

        .nav-link {
            color: #64748b;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.15s ease;
            position: relative;
        }

        .nav-link:hover {
            color: #1e293b;
        }

        .nav-link.active {
            color: #0f172a;
            font-weight: 600;
        }

        .nav-link.active:after {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 4px;
            background: #374151;
            border-radius: 50%;
        }

        /* Footer Styles */
        .modern-footer {
            background: #ffffff;
            color: #374151;
            margin-top: 48px;
            border-top: 1px solid #e5e7eb;
        }

        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 48px 24px 32px;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 48px;
        }

        .footer-left {
            max-width: 400px;
        }

        .footer-logo {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 16px;
        }

        .footer-logo .logo {
            font-size: 20px;
            font-weight: 700;
            color: #0f172a;
        }

.footer-description {
    color: #6b7280;
    font-size: 14px;
    line-height: 1.6;
    margin: 0;
    text-align: justify; /* ðŸ‘ˆ this justifies the text */
}

        .footer-links {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 32px;
        }

        .footer-column h4 {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin: 0 0 16px 0;
        }

        .footer-column {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .footer-column a {
            color: #6b7280;
            text-decoration: none;
            font-size: 14px;
            font-weight: 400;
            transition: color 0.15s ease;
        }

        .footer-column a:hover {
            color: #374151;
        }

        .footer-bottom {
            border-top: 1px solid #e5e7eb;
            padding: 24px 0;
        }

        .footer-bottom-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .footer-bottom p {
            color: #9ca3af;
            font-size: 14px;
            margin: 0;
        }

        .footer-social span {
            color: #9ca3af;
            font-size: 14px;
        }

        /* Profile Dropdown Styles */
        .user-profile {
            position: relative;
        }

        .profile-dropdown {
            position: relative;
        }

        .profile-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            background: none;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 14px;
            color: #374151;
        }

        .profile-btn:hover {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .profile-img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            object-fit: cover;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            min-width: 200px;
            z-index: 1000;
            display: none;
            margin-top: 4px;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-item {
            padding: 12px 16px;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
            cursor: pointer;
            transition: background 0.15s ease;
            font-size: 14px;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .dropdown-item:hover {
            background: #f9fafb;
        }

        .dropdown-divider {
            height: 1px;
            background: #e5e7eb;
            margin: 4px 0;
        }

        .profile-email {
            font-size: 12px;
            color: #6b7280;
        }

        .logout-btn {
            color: #dc2626;
        }

        .logout-btn:hover {
            background: #fef2f2;
        }

        /* STAAAR Loading Modal Styles */
        .loading-modal-container {
            background: white;
            border-radius: 16px;
            padding: 48px 40px;
            max-width: 500px;
            margin: auto;
            text-align: center;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            border: 1px solid #e5e7eb;
        }

        .loading-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
        }

        .loading-icon {
            margin-bottom: 8px;
        }

        .loading-title {
            font-size: 24px;
            font-weight: 700;
            color: #111827;
            margin: 0;
            letter-spacing: -0.025em;
        }

        .loading-message {
            font-size: 16px;
            color: #374151;
            margin: 0;
            line-height: 1.6;
            max-width: 400px;
        }

        .loading-submessage {
            font-size: 14px;
            color: #6b7280;
            margin: 0;
            line-height: 1.5;
            max-width: 380px;
        }

        .progress-container {
            width: 100%;
            max-width: 320px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f3f4f6;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 12px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc2626 0%, #ef4444 100%);
            border-radius: 8px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        .sub-line {
            font-size: 12px;
            font-weight: 400;
            color: #cbd5e1;
            opacity: 0.9;
        }

        /* Reveal.js Styles */
        .reveal {
            width: 100%;
            height: 70vh;
            max-height: 600px;
        }

        .reveal .slides section {
            background: white !important;
            border-radius: 12px !important;
            padding: 24px !important;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1) !important;
            border: 1px solid #e2e8f0 !important;
        }

        .slide-overview {
            display: grid;
            grid-template-columns: 40% 60%;
            grid-template-rows: auto 1fr;
            gap: 24px;
            height: 100%;
            min-height: 0;
        }

        .slide-overview .overview-title {
            grid-column: 1 / -1;
            grid-row: 1;
        }

        .slide-overview .overview-video-section {
            grid-column: 1;
            grid-row: 2;
        }

        .slide-overview .overview-map-section {
            grid-column: 2;
            grid-row: 2;
        }

        .slide-row-detail {
            display: grid;
            grid-template-columns: 40% 60%;
            grid-template-rows: auto 1fr;
            gap: 24px;
            height: 100%;
            min-height: 0;
        }

        .slide-row-detail .slide-titles-section {
            grid-column: 1 / -1;
            grid-row: 1;
        }

        .slide-row-detail .slide-image-section {
            grid-column: 1;
            grid-row: 2;
        }

        .slide-row-detail .slide-details-section {
            grid-column: 2;
            grid-row: 2;
        }

        .slide-image-section {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border-radius: 16px;
            padding: 16px;
            border: 2px solid #e2e8f0;
            position: relative;
        }

        .slide-large-image {
            width: 100%;
            height: auto;
            max-height: 380px;
            aspect-ratio: 16/9;
            object-fit: cover;
            border-radius: 12px;
            border: 3px solid #ffffff;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
        }

        .slide-image-placeholder {
            width: 100%;
            height: 380px;
            aspect-ratio: 16/9;
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
            border: 3px dashed #94a3b8;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            color: #64748b;
        }

        .slide-image-placeholder-text {
            font-size: 16px;
            color: #64748b;
            font-weight: 600;
            margin-top: 16px;
            text-align: center;
        }

        .slide-image-caption {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: #475569;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 14px;
            border-radius: 20px;
            border: 1px solid #e2e8f0;
            backdrop-filter: blur(8px);
        }

        .slide-details-section {
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .slide-category-title {
            font-size: 20px;
            font-weight: 800;
            margin-bottom: 16px;
            padding: 12px 16px;
            border-radius: 12px;
            text-align: center;
            color: white;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .slide-connected-highlight {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
            border: 2px solid #3b82f6;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            position: relative;
        }

        .slide-connected-badge {
            position: absolute;
            top: -8px;
            left: 12px;
            background: #3b82f6;
            color: white;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 4px 8px;
            border-radius: 8px;
        }

        .slide-connected-text {
            font-size: 18px;
            font-weight: 700;
            color: #1e293b;
            line-height: 1.3;
            margin-top: 2px;
        }

        .slide-context-section {
            margin-bottom: 12px;
        }

        .slide-context-label {
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .slide-context-items {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .slide-context-item {
            background: #f1f5f9;
            border: 1px solid #e2e8f0;
            padding: 3px 6px;
            border-radius: 8px;
            font-size: 10px;
            color: #64748b;
            font-weight: 500;
        }

        .slide-text-input-box {
            background: linear-gradient(135deg, #fefefe 0%, #f9fafb 100%);
            border: 3px dashed #94a3b8;
            border-radius: 12px;
            padding: 16px;
            flex: 1;
            min-height: 160px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(148, 163, 184, 0.1);
        }

        .slide-text-input-box:hover {
            border-color: #3b82f6;
        }

        .slide-input-label {
            font-size: 12px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            text-align: center;
        }

        .slide-input-textarea {
            flex: 1;
            border: none;
            outline: none;
            font-size: 13px;
            color: #1e293b;
            line-height: 1.4;
            resize: none;
            background: transparent;
            font-family: inherit;
        }

        .slide-input-textarea::placeholder {
            color: #94a3b8;
            font-style: italic;
        }

        .slide-input-instructions {
            font-size: 9px;
            color: #94a3b8;
            text-align: center;
            margin-top: 8px;
            font-style: italic;
        }

        /* Reveal.js Navigation Customization */
        .reveal .controls {
            color: #3b82f6;
        }

        .reveal .controls button {
            color: #3b82f6;
        }

        .reveal .progress {
            color: #3b82f6;
        }

        /* Custom Reveal.js Controls */
        .reveal .controls {
            bottom: 20px;
            right: 20px;
        }

        .reveal .controls button {
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e2e8f0;
        }

        .reveal .controls button:hover {
            background: #f8fafc;
            border-color: #3b82f6;
        }

        /* Responsive adjustments */
        @media (max-height: 800px) {
            .header-section {
                padding: 10px 20px;
            }

            .brand-name {
                font-size: 20px;
                margin-bottom: 4px;
            }

            .hero-line {
                font-size: 12px;
                margin-bottom: 2px;
            }

            .sub-line {
                font-size: 11px;
            }

            .video-container {
                max-height: 200px;
            }

            .insight-table {
                font-size: 8px;
                border-spacing: 4px;
            }

            .text-cell {
                height: 50px;
                font-size: 7px;
            }

            .image-cell {
                height: 50px;
            }

            .image-placeholder {
                height: 46px;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Simple slide navigation instead of Reveal.js -->
    <style id="simple-slides">
        .simple-slides-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 120px);
            overflow: hidden;
            flex: 1;
        }
        .simple-slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.3s ease;
            background: white;
            border-radius: 12px;
            padding: 24px;
            border: 1px solid #e5e7eb;
            overflow-y: auto;
        }
        .simple-slide.active {
            opacity: 1;
        }
        .slide-navigation {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }
        .nav-btn {
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .nav-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }
        .nav-btn:disabled {
            background: #f3f4f6;
            color: #9ca3af;
            cursor: not-allowed;
            border-color: #e5e7eb;
        }
        .slide-counter {
            background: white;
            color: #374151;
            border: 1px solid #d1d5db;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            margin: 0 15px;
            align-self: center;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://unpkg.com/pptxgenjs@3.12.0/dist/pptxgen.bundle.js" onload="console.log('PptxGenJS loaded successfully')" onerror="console.error('Failed to load PptxGenJS')"></script>
</head>

<body>
    <!-- Modern Header -->
    <header class="modern-header">
        <div class="header-content">
            <div class="logo-section">
                <h1 class="logo">STRATEGY â‡¨ STAAAR</h1>
                <span class="logo-tagline">PRO</span>
            </div>
            <nav class="header-nav">
                <a href="#" class="nav-link">Features</a>
                <a href="#" class="nav-link">Templates</a>
                <a href="#" class="nav-link">Export</a>
                <a href="#" class="nav-link active">Dashboard</a>
                <div class="user-profile" id="userProfile" style="display: none;">
                    <div class="profile-dropdown">
                        <button class="profile-btn" id="profileBtn">
                            <img id="profileImage" src="" alt="Profile" class="profile-img">
                            <span id="profileName"></span>
                            <i class="bi bi-chevron-down"></i>
                        </button>
                        <div class="dropdown-menu" id="dropdownMenu">
                            <div class="dropdown-item" id="profileInfo">
                                <div class="profile-email" id="profileEmail"></div>
                            </div>
                            <div class="dropdown-divider"></div>
                            <button class="dropdown-item logout-btn" id="logoutBtn">
                                <i class="bi bi-box-arrow-right"></i>
                                Logout
                            </button>
                        </div>
                    </div>
                </div>
            </nav>
        </div>
    </header>

    <div class="container">
        <!-- 3-Step Revenue Generator -->   
        <div class="left-panel-card">
            <div class="revenue-steps">
            <h3 class="revenue-title">Turn your strategy into a STAAAR <br> Strategy  that <em>Adds</em>, <em>Assures</em> & <em>Accelerates</em> Your Revenue in minutes not months</h3>

            <!-- Step 1: Agency/Brand Selection -->
            <div class="step-card">
                <div class="step-header">
                    <span class="step-number">1</span>
                    <h3>What do advertisers & agencies search for?</h3>
                    <div class="step-description">Pick what's in demand with a ready-made list in seconds â€” no more endless guessing.<br><br> This <em>adds</em> to your income today because you deliver exactly what advertisers, agencies, achievers (Startup Founders) repeat buy.</div>
                </div>
                <div class="step-content">
                    <button class="step-btn" id="selectAgencyBtn">
                        <i class="bi bi-building"></i>
                        Choose a STAAARs
                    </button>
                    <div class="selected-display">
                        <div class="selected-label">Selected:</div>
                        <div class="selected-name">Loading...</div>
                        <div class="selected-details">Loading strategy data...</div>
                    </div>
                </div>
            </div>

            <!-- Step 2: Unique Insights -->
            <div class="step-card">
                <div class="step-header">
                    <span class="step-number">2</span>
                    <h3>What insight do you have that AI canâ€™t?</h3>
                    <div class="step-description">Shine with personal, unique, actionable insights that create wins or prevent losses â€” not found in generic AI. Build with click-and-drag in minutes, no more discount pressure or undervaluing your work. <br><br>This <em>assures</em> your income because you bring what AI can't.</div>
                </div>
                <div class="step-content">
                    <div class="video-container">
                        <video id="videoPlayer" controls>
                            <source src="" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                    </div>

                    <div class="file-input-wrapper">
                        <button id="openVideoModal" class="file-input-label" style="border: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); cursor: pointer;">
                            <i class="bi bi-play-circle"></i>
                            Load Anchor Video File
                        </button>
                    </div>

                    <div class="row-selector" id="dynamicRowSelector">
                        <!-- Row buttons will be populated dynamically based on table rows -->
                    </div>
                </div>
            </div>

            <!-- Step 3: Brand & Income -->
            <div class="step-card">
                <div class="step-header">
                    <span class="step-number">3</span>
                    <h3>How will you deliver it so theyâ€™ll pay?</h3>
                    <div class="step-description">Match your buyer's brand, customize instantly with colors, and hand over work they can use in minutes â€” no more chasing invoices.<br><br> This <em>accelerates</em> your income by giving agencies and brands ready-to-use value.</div>
                </div>
                <div class="step-content">

                    <button class="step-btn" id="colorCustomizeBtn">
                        <i class="bi bi-palette"></i>
                        Customize Colors
                    </button>

                    <button class="step-btn primary" id="downloadBtn">
                        <i class="bi bi-coin"></i>
                        Turn Your Strategy to Income Now
                    </button>
                </div>
            </div>

            <!-- Status and Toast -->
            <div class="status" id="status"></div>
            <div class="toast-container" id="toastContainer"></div>
            </div>
        </div>

        <!-- Strategy Selection Modal -->
        <div class="modal-overlay" id="strategyModal">
            <div class="modal-container">
                <div class="modal-header">
                    <h2><i class="bi bi-clipboard-data"></i> Select Your STAAAR â€” that advertisers, agencies and achievers repeat buy.</h2>
                    <button class="modal-close" id="closeStrategyModal">
                        <i class="bi bi-x"></i>
                    </button>
                </div>

                <div class="modal-tabs">
                    <button class="tab-btn active" data-tab="presets"><i class="bi bi-grid-3x3-gap"></i> Presets</button>
                    <button class="tab-btn" data-tab="custom"><i class="bi bi-file-earmark-plus"></i> Bring Your Own Strategy</button>
                </div>

                <div class="tab-content active" id="presets-tab">
                    <!-- Filters -->
                    <div class="filters-section">
                        <h3><i class="bi bi-funnel"></i> Filter Strategies</h3>
                        <div class="filter-group">
                            <label><i class="bi bi-currency-dollar"></i> Income Potential:</label>
                            <div class="filter-checkboxes">
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="very-high" data-filter="pricing">
                                    <i class="bi bi-circle-fill text-danger"></i> Very High ($4,000+)
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="high" data-filter="pricing">
                                    <i class="bi bi-circle-fill text-warning"></i> High ($2,000-$4,000)
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="medium" data-filter="pricing">
                                    <i class="bi bi-circle-fill text-success"></i> Medium (<$2,000)
                                </label>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label><i class="bi bi-people"></i> Target Buyer:</label>
                            <div class="filter-checkboxes">
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="agency" data-filter="buyer">
                                    <i class="bi bi-building"></i> Agency
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="brand" data-filter="buyer">
                                    <i class="bi bi-award"></i> Brand
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="consultant" data-filter="buyer">
                                    <i class="bi bi-person-badge"></i> Consultant
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="cmo" data-filter="buyer">
                                    <i class="bi bi-person-gear"></i> CMO
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="performance" data-filter="buyer">
                                    <i class="bi bi-graph-up"></i> Performance Marketing
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="legal" data-filter="buyer">
                                    <i class="bi bi-shield-check"></i> Legal/Compliance
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="creative" data-filter="buyer">
                                    <i class="bi bi-palette"></i> Creative
                                </label>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label><i class="bi bi-clock"></i> Time Required:</label>
                            <div class="filter-checkboxes">
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="quick" data-filter="speed">
                                    <i class="bi bi-lightning-charge"></i> <30min
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="medium" data-filter="speed">
                                    <i class="bi bi-clock"></i> 30-60min
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="long" data-filter="speed">
                                    <i class="bi bi-hourglass-split"></i> >60min
                                </label>
                            </div>
                        </div>
                        <div class="filter-group">
                            <label><i class="bi bi-exclamation-triangle"></i> Market Urgency:</label>
                            <div class="filter-checkboxes">
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="HIGH" data-filter="urgency">
                                    <i class="bi bi-exclamation-triangle-fill text-danger"></i> High
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="MEDIUM" data-filter="urgency">
                                    <i class="bi bi-exclamation-diamond-fill text-warning"></i> Medium
                                </label>
                                <label class="filter-checkbox">
                                    <input type="checkbox" value="LOW" data-filter="urgency">
                                    <i class="bi bi-check-circle-fill text-success"></i> Low
                                </label>
                            </div>
                        </div>
                        <div class="filter-actions">
                            <button class="btn-secondary" id="clearFilters"><i class="bi bi-x-circle"></i> Clear All</button>
                        </div>
                    </div>

                    <!-- Strategy Cards -->
                    <div class="strategy-grid" id="strategyGrid">
                        <!-- Cards will be populated by JavaScript -->
                    </div>
                </div>

                <div class="tab-content" id="custom-tab">
                    <div class="custom-strategy-section">
                        <h3>Paste your CSV strategy below:</h3>
                        <p class="format-hint">
                            <strong>Format:</strong> Title, Description<br>
                            <strong>Rows 2-7:</strong> icon_name, text_value (repeat for each column)
                        </p>

                        <textarea id="csvInput" placeholder="TikTok Trend Tracking,Track viral content trends for agencies
TrendingUp,Trending Now,Activity,Viral Content,Star,Top Trends,Crown,Market Leader
Eye,Watching Trends,Users,Community Pulse,Heart,Engagement,Search,Discovery
Target,Precise Targeting,Zap,Rapid Response,Trophy,Achievement,Gem,Premium
DollarSign,Revenue Impact,BarChart3,Growth Metrics,Award,Success,Rocket,Scale
Calendar,Content Planning,Clock,Time Optimization,Bell,Alerts,Shield,Protection
Rocket,Scale Success,Crown,Market Leadership,Gem,Innovation,Infinity,Unlimited"></textarea>

                        <div class="csv-info">
                            <p><strong>Requirements:</strong> Min 4Ã—7, Max 6Ã—7 | First row: headers | Rows 2-7: icon,text pairs</p>
                        </div>

                        <div class="csv-actions">
                            <button class="btn-secondary" id="cancelCustom">Cancel</button>
                            <button class="btn-primary" id="validateCsv">Validate & Preview</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="map-section">
            <!-- Floating Title Card -->
            <div class="floating-title-card">
                <h1 class="main-title">Loading...</h1>
                <p class="subtitle">Loading strategy data...</p>
            </div>

            <table class="insight-table" id="insightTable">
                <!-- Table content will be loaded dynamically -->
                <tr>
                    <td colspan="8" style="text-align: center; padding: 40px; color: #64748b;">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 12px;">
                            <i class="bi bi-hourglass-split" style="font-size: 24px; color: #3b82f6; animation: pulse 2s infinite;"></i>
                            <div style="font-size: 14px; font-weight: 500;">Loading strategy content...</div>
                        </div>
                    </td>
                </tr>
            </table>
        </div>

    </div>

    <!-- STAAAR Loading Modal -->
    <div class="crop-modal" id="staaaarLoadingModal" style="display: none; z-index: 20000;">
        <div class="loading-modal-container">
            <div class="loading-content">
                <div class="loading-icon">
                    <i class="bi bi-stars" style="font-size: 48px; color: #dc2626; animation: pulse 2s infinite;"></i>
                </div>
                <h2 class="loading-title">Please waitâ€¦</h2>
                <p class="loading-message">Your strategy is becoming a <strong>STAAAR</strong> â€” a Strategy that Adds, Assures, and Automates Revenue.</p>
                <p class="loading-submessage">Sell it to brands, agencies, and fellow strategists to unlock multiple incomes today!</p>

                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressText">0%</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Crop Modal -->
    <div class="crop-modal" id="cropModal">
        <div class="crop-container">
            <h3 style="margin: 0 0 20px 0; text-align: center; font-size: 18px; font-weight: 600; color: #111827;">Select Focus Area</h3>
            <div style="position: relative; display: inline-block;">
                <img id="cropImage" class="crop-image" src="" alt="Crop Preview">
                <div class="crop-selector" id="cropSelector">
                    <!-- Fixed 3:2 rectangle - only moveable, not resizable -->
                </div>
            </div>

            <div style="margin: 16px 0; padding: 12px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 6px; font-size: 13px; color: #6b7280; line-height: 1.4;">
                <div style="font-weight: 500; color: #374151; margin-bottom: 6px;">How to use:</div>
                â€¢ <strong>Fixed 3:2 rectangle</strong> matches final output dimensions<br>
                â€¢ <strong>Drag to position</strong> the rectangle over your focus area<br>
                â€¢ <strong>Exact area</strong> inside rectangle will be captured
            </div>

            <div class="crop-controls" style="display: flex; gap: 8px; justify-content: center; margin-top: 20px;">
                <button class="crop-btn confirm" id="confirmCrop">Apply Focus</button>
                <button class="crop-btn cancel" id="cancelCrop">Cancel</button>
            </div>
        </div>
    </div>


    <!-- Color Customization Modal -->
    <div class="crop-modal" id="colorModal">
        <div class="crop-container" style="max-width: 95vw; max-height: 90vh; overflow-y: auto; min-width: 900px;">
            <!-- Header -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid #e2e8f0;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                        <i class="bi bi-palette" style="color: white; font-size: 18px;"></i>
                    </div>
                    <div>
                        <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1e293b;">Brand Colors</h2>
                        <p style="margin: 0; font-size: 14px; color: #64748b;">Customize colors to match your brand identity</p>
                    </div>
                </div>
                <button id="closeColorModal" style="width: 32px; height: 32px; border: none; background: #f1f5f9; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease;">
                    <i class="bi bi-x" style="font-size: 18px; color: #64748b;"></i>
                </button>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 32px;">
                <!-- Left Section: Category Colors -->
                <div style="background: #f8fafc; border-radius: 12px; padding: 20px; border: 1px solid #e2e8f0;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <i class="bi bi-grid-3x3-gap" style="color: #3b82f6; font-size: 16px;"></i>
                        <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1e293b;">Category Colors</h3>
                    </div>
                    <p style="margin: 0 0 20px 0; font-size: 13px; color: #64748b;">Each row can have its own category color</p>

                    <div id="dynamicCategoryButtons" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 20px;">
                        <!-- Categories will be populated dynamically from the table -->
                    </div>

                    <div id="categoryColorSection" style="display: block;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                            <span id="selectedRowLabel" style="font-size: 16px; font-weight: 600; color: #1e293b;">Select a category</span>
                        </div>

                        <!-- Category Background Color -->
                        <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0; margin-bottom: 16px;">
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #1e293b;">
                                <i class="bi bi-paint-bucket" style="color: #64748b;"></i>
                                Background Color
                            </label>
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <input type="color" id="selectedRowColorPicker" value="#8BC34A" style="width: 60px; height: 40px; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer;">
                                <div style="flex: 1; height: 40px; background: #8BC34A; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: white;" id="categoryBgPreview">
                                    Category Background
                                </div>
                            </div>
                        </div>

                        <!-- Category Text Color -->
                        <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0;">
                            <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #1e293b;">
                                <i class="bi bi-fonts" style="color: #64748b;"></i>
                                Text Color
                            </label>
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                                <input type="color" id="categoryTextColorPicker" value="#ffffff" style="width: 60px; height: 40px; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer;">
                                <div style="flex: 1; height: 40px; background: #8BC34A; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: white;" id="categoryTextPreview">
                                    Sample Category Text
                                </div>
                            </div>
                            <button id="autoContrastBtn" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; background: #f8fafc; color: #475569; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">
                                <i class="bi bi-magic" style="margin-right: 4px;"></i>Auto Contrast
                            </button>
                        </div>

                        <!-- Apply to All Button -->
                        <button id="applyToAllCategories" style="width: 100%; padding: 12px; border: 1px solid #e2e8f0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.2s ease; margin-top: 16px;">
                            <i class="bi bi-check-all" style="margin-right: 4px;"></i>Apply to All Categories
                        </button>
                    </div>
                </div>

                <!-- Right Section: Content Colors -->
                <div style="background: #f8fafc; border-radius: 12px; padding: 20px; border: 1px solid #e2e8f0;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 16px;">
                        <i class="bi bi-textarea-t" style="color: #10b981; font-size: 16px;"></i>
                        <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1e293b;">Content Colors</h3>
                    </div>
                    <p style="margin: 0 0 20px 0; font-size: 13px; color: #64748b;">Same colors applied to all content cells</p>

                    <!-- Content Background Color -->
                    <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0; margin-bottom: 16px;">
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #1e293b;">
                            <i class="bi bi-paint-bucket" style="color: #64748b;"></i>
                            Background Color
                        </label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="color" id="contentBgColorPicker" value="#f5f5f5" style="width: 60px; height: 40px; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer;">
                            <div style="flex: 1; height: 40px; background: #f5f5f5; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #64748b;" id="contentBgPreview">
                                Content Background
                            </div>
                        </div>
                    </div>

                    <!-- Content Text Color -->
                    <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0; margin-bottom: 16px;">
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #1e293b;">
                            <i class="bi bi-fonts" style="color: #64748b;"></i>
                            Text Color
                        </label>
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <input type="color" id="contentTextColorPicker" value="#1e293b" style="width: 60px; height: 40px; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer;">
                            <div style="flex: 1; height: 40px; background: #f5f5f5; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #1e293b;" id="contentTextPreview">
                                Sample Text Color
                            </div>
                        </div>
                        <button id="contentAutoContrastBtn" style="width: 100%; padding: 8px; border: 1px solid #e2e8f0; background: #f8fafc; color: #475569; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">
                            <i class="bi bi-magic" style="margin-right: 4px;"></i>Auto Contrast
                        </button>
                    </div>

                    <!-- Content Icon Color -->
                    <div style="background: white; border-radius: 8px; padding: 16px; border: 1px solid #e2e8f0;">
                        <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; font-size: 14px; font-weight: 500; color: #1e293b;">
                            <i class="bi bi-star" style="color: #64748b;"></i>
                            Icon Color
                        </label>
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <input type="color" id="contentIconColorPicker" value="#3b82f6" style="width: 60px; height: 40px; border: 1px solid #e2e8f0; border-radius: 6px; cursor: pointer;">
                            <div style="flex: 1; height: 40px; background: #f5f5f5; border: 1px solid #e2e8f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #64748b;" id="contentIconPreview">
                                <i class="bi bi-star" style="font-size: 16px; color: #3b82f6;" id="iconPreviewIcon"></i>
                                <span style="margin-left: 8px;">Icon Color</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div style="display: flex; justify-content: flex-end; gap: 12px; margin-top: 24px; padding-top: 20px; border-top: 1px solid #e2e8f0;">
                <button id="cancelColorChanges" style="padding: 10px 20px; border: 1px solid #e2e8f0; background: white; color: #64748b; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.2s;">
                    <i class="bi bi-x-lg" style="font-size: 12px;"></i>
                    Cancel
                </button>
                <button id="applyColorChanges" style="padding: 10px 20px; border: none; background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); color: white; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: all 0.2s;">
                    <i class="bi bi-check-lg" style="font-size: 12px;"></i>
                    Apply Colors
                </button>
            </div>
        </div>
    </div>

    <!-- Video Selection Modal -->
    <div class="crop-modal" id="videoModal">
        <div class="crop-container" style="max-width: 800px; max-height: 80vh; overflow-y: auto;">
            <!-- Header -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; padding-bottom: 16px; border-bottom: 1px solid #e2e8f0;">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="width: 40px; height: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; display: flex; align-items: center; justify-content: center;">
                        <i class="bi bi-play-circle" style="color: white; font-size: 18px;"></i>
                    </div>
                    <div>
                        <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1e293b;">Select Video</h2>
                        <p style="margin: 0; font-size: 14px; color: #64748b;">Choose from server videos or upload your own</p>
                    </div>
                </div>
                <button id="closeVideoModal" style="width: 32px; height: 32px; border: none; background: #f1f5f9; border-radius: 6px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease;">
                    <i class="bi bi-x" style="font-size: 18px; color: #64748b;"></i>
                </button>
            </div>

            <!-- Upload Section -->
            <div style="background: #f8fafc; border-radius: 12px; padding: 20px; border: 1px solid #e2e8f0; margin-bottom: 24px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <i class="bi bi-upload" style="color: #10b981; font-size: 16px;"></i>
                    <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1e293b;">Upload from Computer</h3>
                </div>
                <div class="file-input-wrapper" style="margin: 0;">
                    <input type="file" id="modalVideoInput" accept="video/*" style="display: none;">
                    <button id="modalUploadBtn" style="width: 100%; padding: 12px; border: 1px dashed #cbd5e1; background: white; color: #64748b; border-radius: 8px; font-size: 14px; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; gap: 8px;">
                        <i class="bi bi-cloud-upload" style="font-size: 16px;"></i>
                        Choose Video File
                    </button>
                </div>
            </div>

            <!-- Available Videos Section -->
            <div style="background: #f8fafc; border-radius: 12px; padding: 20px; border: 1px solid #e2e8f0;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                    <i class="bi bi-collection-play" style="color: #3b82f6; font-size: 16px;"></i>
                    <h3 style="margin: 0; font-size: 16px; font-weight: 600; color: #1e293b;">Available Videos</h3>
                </div>
                <div id="serverVideosList" style="display: grid; gap: 12px;">
                    <!-- Loading state -->
                    <div id="videosLoading" style="text-align: center; padding: 40px; color: #64748b;">
                        <i class="bi bi-hourglass-split" style="font-size: 24px; margin-bottom: 8px; display: block;"></i>
                        Loading videos...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Preview Modal -->
    <div class="crop-modal" id="downloadModal">
        <div class="crop-container" style="width: 100vw; height: 100vh; max-width: none; max-height: none; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box;">

            <!-- Simple Slides Container -->
            <div class="simple-slides-container" id="slidesContainer">
                <!-- Slide 1: Overview -->
                <div class="simple-slide active slide-overview">
                    <div class="overview-title" style="grid-column: 1 / -1; margin-bottom: 20px; text-align: center; font-size: 28px; font-weight: 800; color: #1e293b; text-transform: uppercase; letter-spacing: 1px;">
                         
                    </div>

                    <div class="overview-video-section">
                        <div style="background: #f9fafb; border-radius: 12px; padding: 16px; border: 1px solid #f3f4f6; height: 100%; display: flex; flex-direction: column; justify-content: center;">
                            <div style="background: #000; border-radius: 12px; overflow: hidden; margin-bottom: 12px;">
                                <video id="previewVideo" style="width: 100%; height: auto; background: #000; max-height: 380px; border-radius: 8px;"></video>
                            </div>
                            <div style="text-align: center; font-size: 12px; color: #475569; font-weight: 600; background: rgba(255, 255, 255, 0.95); padding: 6px 14px; border-radius: 20px; border: 1px solid #e2e8f0; margin: 0 auto;">
                                Video Source
                            </div>
                        </div>
                    </div>

                    <div class="overview-map-section">
                        <div id="mapPreview" style="background: #f9fafb; border-radius: 12px; padding: 20px; border: 1px solid #f3f4f6; overflow: auto; height: 100%;">
                            <!-- Map content will be cloned here -->
                        </div>
                    </div>
                </div>

                <!-- Individual row slides will be generated dynamically -->

                <!-- Navigation -->
                <div class="slide-navigation">
                    <button class="nav-btn" id="prevSlide">â€¹</button>
                    <div class="slide-counter" id="slideCounter">1 / 1</div>
                    <button class="nav-btn" id="nextSlide">â€º</button>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px; flex-shrink: 0;">
                <button class="crop-btn confirm" id="downloadCurrentSlide" style="margin: 0 8px; padding: 12px 20px; font-size: 14px; font-weight: 500; background: white; color: #374151; border: 1px solid #d1d5db; border-radius: 8px; display: none; align-items: center; gap: 8px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.15s ease;">
                    <i class="bi bi-download"></i>
                    Download Current Slide
                </button>
                <button class="crop-btn confirm" id="downloadAllSlides" style="margin: 0 8px; padding: 12px 20px; font-size: 14px; font-weight: 500; background: #0f172a; color: white; border: 1px solid #0f172a; border-radius: 8px; display: none; align-items: center; gap: 8px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.15s ease;">
                    <i class="bi bi-file-earmark-zip"></i>
                    Download All Slides (ZIP)
                </button>
                <button class="crop-btn confirm" id="downloadPPT" style="margin: 0 8px; padding: 12px 20px; font-size: 14px; font-weight: 500; background: #dc2626; color: white; border: 1px solid #dc2626; border-radius: 8px; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.15s ease;">
                    <i class="bi bi-star-fill"></i>
                    Generate my STAAAR
                </button>
                <button class="crop-btn cancel" id="cancelDownload" style="margin: 0 8px; padding: 12px 20px; font-size: 14px; font-weight: 500; background: white; color: #6b7280; border: 1px solid #d1d5db; border-radius: 8px; display: inline-flex; align-items: center; gap: 8px; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.15s ease;">
                    <i class="bi bi-x-lg"></i>
                    Close Presentation
                </button>
            </div>
        </div>
    </div>


    <script>
        // Strategy data management
        let STRATEGY_PRESETS = []; // Will be loaded from JSON
        // No caching - always fetch fresh data for development

        // Helper functions for filtering
        function getIncomeLevel(pricing) {
            // Extract all numbers from pricing string
            const numbers = pricing.match(/\d+,?\d*/g) || [];
            const prices = numbers.map(n => parseInt(n.replace(',', '')));

            // Use the maximum price in the range for categorization
            const maxPrice = Math.max(...prices);

            if (maxPrice >= 4000) return 'very-high';
            if (maxPrice >= 2000) return 'high';
            return 'medium';
        }

        function getSpeedLevel(speed) {
            if (speed.includes('<30') || speed.includes('15-30') || speed.includes('20-30')) {
                return 'quick';
            } else if (speed.includes('30-45') || speed.includes('30-60') || speed.includes('45-60')) {
                return 'medium';
            } else {
                return 'long';
            }
        }

        function getBuyerCategories(whoSearches) {
            const categories = [];
            const lower = whoSearches.toLowerCase();

            // Agency roles
            if (lower.includes('agency') || lower.includes('agencies') ||
                lower.includes('account director') || lower.includes('creative director')) {
                categories.push('agency');
            }

            // Brand roles (including brand managers, brand strategists, etc.)
            if (lower.includes('brand') || lower.includes('marketing director') ||
                lower.includes('marketing manager') || lower.includes('product manager')) {
                categories.push('brand');
            }

            // Consultant roles
            if (lower.includes('consultant') || lower.includes('strategist') ||
                lower.includes('leadership coach') || lower.includes('specialist')) {
                categories.push('consultant');
            }

            // CMO and executive roles
            if (lower.includes('cmo') || lower.includes('director') ||
                lower.includes('executive') || lower.includes('corporate')) {
                categories.push('cmo');
            }

            // Performance Marketing roles
            if (lower.includes('performance') || lower.includes('campaign manager') ||
                lower.includes('e-commerce') || lower.includes('social media')) {
                categories.push('performance');
            }

            // Legal/Compliance roles
            if (lower.includes('legal') || lower.includes('compliance') ||
                lower.includes('ethics') || lower.includes('safety')) {
                categories.push('legal');
            }

            // Creative roles
            if (lower.includes('creative') || lower.includes('innovation') ||
                lower.includes('design') || lower.includes('content')) {
                categories.push('creative');
            }

            return categories;
        }

        // Strategy loading functions
        async function loadStrategyMetadata() {
            try {
                const response = await fetch('./data/strategy-metadata.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const strategies = await response.json();
                STRATEGY_PRESETS = strategies;
                console.log(`âœ… Loaded ${strategies.length} strategies from strategy-metadata.json`);
                return true;
            } catch (error) {
                console.error('Error loading strategy metadata:', error);
                showStatus('Failed to load strategy data from external file', 'error');
                return false;
            }
        }

        async function loadStrategyContent(strategyId) {
            // Always fetch fresh content (no caching for development)
            console.log('ðŸ” DEBUG: Loading strategy content for ID:', strategyId);

            try {
                const strategy = STRATEGY_PRESETS.find(s => s.id === strategyId);
                if (!strategy) throw new Error('Strategy not found');

                console.log('ðŸ” DEBUG: Strategy found:', strategy);
                console.log('ðŸ” DEBUG: Loading file:', `./data/strategies/${strategy.file}`);

                const response = await fetch(`./data/strategies/${strategy.file}`);
                if (!response.ok) throw new Error('Failed to load strategy content');

                const content = await response.json();

                console.log('ðŸ” DEBUG: Loaded content:', content);
                console.log('ðŸ” DEBUG: Headers:', content.headers);
                if (content.data && content.data[0]) {
                    console.log('ðŸ” DEBUG: First row data:', content.data[0]);
                }

                // No caching - return fresh content

                return content;
            } catch (error) {
                console.error('Error loading strategy content:', error);
                showStatus('Failed to load strategy content', 'error');
                return null;
            }
        }

        // Bootstrap Icons Integration - Static CSS already loaded in head

        const bootstrapIconMapping = {
            0: ['bi-skip-forward', 'bi-heart', 'bi-chat-dots', 'bi-share', 'bi-camera-video', 'bi-cart-check'],
            1: ['bi-x-circle', 'bi-eye', 'bi-shield-check', 'bi-hand-thumbs-up', 'bi-check-circle', 'bi-award'],
            2: ['bi-tv', 'bi-arrow-repeat', 'bi-lightbulb', 'bi-eye-fill', 'bi-brain', 'bi-star-fill'],
            3: ['bi-dash-circle', 'bi-play-circle', 'bi-arrow-up-short', 'bi-bullseye', 'bi-trophy', 'bi-gem'],
            4: ['bi-dash', 'bi-question-circle', 'bi-emoji-smile', 'bi-fire', 'bi-crown', 'bi-rocket-takeoff'],
            5: ['bi-box', 'bi-graph-up', 'bi-person-check', 'bi-person-badge', 'bi-house-heart', 'bi-fingerprint']
        };

        function addBootstrapIconsToTextCells() {
            const rows = document.querySelectorAll('tr[data-row]');
            rows.forEach((row, rowIndex) => {
                const textCells = row.querySelectorAll('.text-cell');
                const icons = bootstrapIconMapping[rowIndex] || [];

                textCells.forEach((cell, cellIndex) => {
                    if (icons[cellIndex]) {
                        const currentText = cell.textContent.trim();
                        cell.innerHTML = `
                    <div style="text-align: center; display: flex; flex-direction: column; justify-content: center; height: 100%; padding: 6px;">
                        <i class="${icons[cellIndex]}" style="font-size: 24px; color: #3b82f6; display: block; margin-bottom: 6px;"></i>
                        <div style="font-size: 11px; line-height: 1.2; font-weight: 600; color: #1e293b;">${currentText}</div>
                    </div>
                `;
                        // Don't change the cell's display property - keep it as table-cell
                        cell.style.verticalAlign = 'middle';
                        cell.style.textAlign = 'center';
                    }
                });
            });
        }

        function removeIcons() {
            const textCells = document.querySelectorAll('.text-cell');
            textCells.forEach(cell => {
                const textDiv = cell.querySelector('div > div');
                if (textDiv) {
                    cell.innerHTML = textDiv.textContent;
                    cell.style.verticalAlign = 'middle';
                    cell.style.textAlign = 'center';
                }
            });
        }

        // Icon picker functionality
        const customIconOverrides = {}; // Store custom icon choices

        const expandedIconCategories = {
            business: [
                { icon: 'bi-graph-up', name: 'Growth' },
                { icon: 'bi-graph-down', name: 'Decline' },
                { icon: 'bi-award', name: 'Achievement' },
                { icon: 'bi-bullseye', name: 'Goal' },
                { icon: 'bi-gem', name: 'Premium' },
                { icon: 'bi-briefcase', name: 'Business' },
                { icon: 'bi-trophy', name: 'Success' },
                { icon: 'bi-bar-chart', name: 'Analytics' },
                { icon: 'bi-pie-chart', name: 'Data' },
                { icon: 'bi-graph-up-arrow', name: 'Trending Up' },
                { icon: 'bi-bullseye', name: 'Focus' },
                { icon: 'bi-lightning', name: 'Fast' },
                { icon: 'bi-rocket', name: 'Launch' },
                { icon: 'bi-star', name: 'Quality' },
                { icon: 'bi-diamond', name: 'Value' },
                { icon: 'bi-cash', name: 'Money' },
                { icon: 'bi-bank', name: 'Finance' },
                { icon: 'bi-currency-dollar', name: 'Profit' }
            ],
            emotions: [
                { icon: 'bi-emoji-smile', name: 'Happy' },
                { icon: 'bi-emoji-heart-eyes-fill', name: 'Excited' },
                { icon: 'bi-emoji-frown', name: 'Sad' },
                { icon: 'bi-emoji-angry', name: 'Angry' },
                { icon: 'bi-emoji-neutral', name: 'Neutral' },
                { icon: 'bi-emoji-wink', name: 'Playful' },
                { icon: 'bi-fire', name: 'Hot/Trending' },
                { icon: 'bi-heart', name: 'Love' },
                { icon: 'bi-heart-fill', name: 'Strong Love' },
                { icon: 'bi-heartbreak', name: 'Disappointed' },
                { icon: 'bi-exclamation-triangle', name: 'Warning' },
                { icon: 'bi-question-circle', name: 'Confused' },
                { icon: 'bi-check-circle', name: 'Satisfied' },
                { icon: 'bi-x-circle', name: 'Frustrated' },
                { icon: 'bi-star-fill', name: 'Amazing' },
                { icon: 'bi-sun', name: 'Positive' },
                { icon: 'bi-cloud', name: 'Uncertain' },
                { icon: 'bi-lightning-fill', name: 'Energized' }
            ],
            actions: [
                { icon: 'bi-play', name: 'Start' },
                { icon: 'bi-pause', name: 'Wait' },
                { icon: 'bi-stop', name: 'Stop' },
                { icon: 'bi-skip-forward', name: 'Skip' },
                { icon: 'bi-skip-backward', name: 'Go Back' },
                { icon: 'bi-share', name: 'Share' },
                { icon: 'bi-download', name: 'Download' },
                { icon: 'bi-upload', name: 'Upload' },
                { icon: 'bi-eye', name: 'View' },
                { icon: 'bi-eye-slash', name: 'Hide' },
                { icon: 'bi-hand-thumbs-up', name: 'Like' },
                { icon: 'bi-hand-thumbs-down', name: 'Dislike' },
                { icon: 'bi-bookmark', name: 'Save' },
                { icon: 'bi-bookmark-fill', name: 'Saved' },
                { icon: 'bi-arrow-right', name: 'Next' },
                { icon: 'bi-arrow-left', name: 'Previous' },
                { icon: 'bi-arrow-up', name: 'Increase' },
                { icon: 'bi-arrow-down', name: 'Decrease' },
                { icon: 'bi-plus', name: 'Add' },
                { icon: 'bi-dash', name: 'Remove' },
                { icon: 'bi-search', name: 'Search' },
                { icon: 'bi-filter', name: 'Filter' }
            ],
            communication: [
                { icon: 'bi-chat-dots', name: 'Chat' },
                { icon: 'bi-chat-fill', name: 'Message' },
                { icon: 'bi-chat-square', name: 'Comment' },
                { icon: 'bi-reply', name: 'Reply' },
                { icon: 'bi-reply-all', name: 'Reply All' },
                { icon: 'bi-envelope', name: 'Email' },
                { icon: 'bi-envelope-open', name: 'Read Email' },
                { icon: 'bi-telephone', name: 'Call' },
                { icon: 'bi-mic', name: 'Voice' },
                { icon: 'bi-mic-mute', name: 'Muted' },
                { icon: 'bi-speaker', name: 'Audio' },
                { icon: 'bi-megaphone', name: 'Announce' },
                { icon: 'bi-broadcast', name: 'Broadcast' },
                { icon: 'bi-rss', name: 'Feed' },
                { icon: 'bi-newspaper', name: 'News' },
                { icon: 'bi-pencil', name: 'Write' },
                { icon: 'bi-pen', name: 'Edit' },
                { icon: 'bi-quote', name: 'Quote' }
            ],
            technology: [
                { icon: 'bi-laptop', name: 'Computer' },
                { icon: 'bi-phone', name: 'Mobile' },
                { icon: 'bi-tablet', name: 'Tablet' },
                { icon: 'bi-tv', name: 'Screen' },
                { icon: 'bi-camera', name: 'Photo' },
                { icon: 'bi-camera-video', name: 'Video' },
                { icon: 'bi-wifi', name: 'Internet' },
                { icon: 'bi-bluetooth', name: 'Connect' },
                { icon: 'bi-usb', name: 'Transfer' },
                { icon: 'bi-cloud', name: 'Cloud' },
                { icon: 'bi-cloud-download', name: 'Download' },
                { icon: 'bi-cloud-upload', name: 'Upload' },
                { icon: 'bi-cpu', name: 'Processing' },
                { icon: 'bi-memory', name: 'Storage' },
                { icon: 'bi-battery', name: 'Power' },
                { icon: 'bi-battery-charging', name: 'Charging' },
                { icon: 'bi-gear', name: 'Settings' },
                { icon: 'bi-wrench', name: 'Tools' },
                { icon: 'bi-bug', name: 'Issue' },
                { icon: 'bi-shield-check', name: 'Security' }
            ],
            shopping: [
                { icon: 'bi-cart', name: 'Cart' },
                { icon: 'bi-cart-plus', name: 'Add to Cart' },
                { icon: 'bi-cart-check', name: 'Purchase' },
                { icon: 'bi-bag', name: 'Shopping' },
                { icon: 'bi-bag-check', name: 'Bought' },
                { icon: 'bi-credit-card', name: 'Payment' },
                { icon: 'bi-wallet', name: 'Wallet' },
                { icon: 'bi-receipt', name: 'Receipt' },
                { icon: 'bi-gift', name: 'Gift' },
                { icon: 'bi-box', name: 'Package' },
                { icon: 'bi-truck', name: 'Delivery' },
                { icon: 'bi-house', name: 'Home Delivery' },
                { icon: 'bi-shop', name: 'Store' },
                { icon: 'bi-storefront', name: 'Shop' },
                { icon: 'bi-tag', name: 'Price Tag' },
                { icon: 'bi-tags', name: 'Sale' },
                { icon: 'bi-percent', name: 'Discount' },
                { icon: 'bi-basket', name: 'Basket' },
                { icon: 'bi-basket2', name: 'Full Basket' },
                { icon: 'bi-piggy-bank', name: 'Savings' }
            ]
        };

        function enableIconCustomization() {
            //console.log('Enabling icon customization...');
            document.querySelectorAll('.text-cell').forEach((cell, index) => {
                //console.log('Adding customization to cell:', cell);
                cell.classList.add('icon-customizable');
                cell.addEventListener('dblclick', function (e) {
                    //console.log('Double-click detected on cell:', this);
                    e.preventDefault();
                    e.stopPropagation();
                    openIconPicker(this);
                });
            });
            //console.log('Icon customization enabled for all cells');
        }
        function openIconPicker(cell) {
            //console.log('Opening icon picker for cell:', cell);

            // Better way to get the actual text content
            let cellText = '';
            const textDiv = cell.querySelector('div > div');
            if (textDiv) {
                // If it has icon structure, get the text from the inner div
                cellText = textDiv.textContent.trim();
            } else {
                // If it's a plain text cell
                cellText = cell.textContent.trim();
            }

            // Ensure we have some text to show
            if (!cellText || cellText.length === 0) {
                cellText = 'Text Cell';
            }

            const modal = document.createElement('div');
            modal.className = 'crop-modal';
            modal.innerHTML = `
        <div class="crop-container" style="max-width: 70vw; max-height: 90vh;">
            <h3 style="margin-top: 0; text-align: center;">Choose Icon for: "${cellText.substring(0, 40)}${cellText.length > 40 ? '...' : ''}"</h3>
            
            <div style="margin: 15px 0;">
                <label style="font-weight: bold; display: block; margin-bottom: 10px;">Icon Categories:</label>
                <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                    <button class="preset-btn active" data-category="business">Business</button>
                    <button class="preset-btn" data-category="emotions">Emotions</button>
                    <button class="preset-btn" data-category="actions">Actions</button>
                    <button class="preset-btn" data-category="communication">Communication</button>
                    <button class="preset-btn" data-category="technology">Technology</button>
                    <button class="preset-btn" data-category="shopping">Shopping</button>
                </div>
            </div>
            
            <div class="icon-picker-grid" id="iconGrid" style="max-height: 400px; overflow-y: auto;">
                <!-- Icons will be populated here -->
            </div>
            
            <div class="crop-controls">
                <button class="crop-btn confirm" id="applyIcon">Apply Icon</button>
                <button class="crop-btn cancel" id="cancelIcon">Cancel</button>
            </div>
        </div>
    `;

            document.body.appendChild(modal);
            modal.classList.add('show');

            let selectedIcon = null;

            // Populate initial category
            populateIconGrid('business');

            // Category switching
            modal.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', function () {
                    modal.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    populateIconGrid(this.dataset.category);
                });
            });

            function populateIconGrid(category) {
                const grid = modal.querySelector('#iconGrid');
                grid.innerHTML = expandedIconCategories[category].map(item => `
            <div class="icon-option" data-icon="${item.icon}">
                <i class="${item.icon}" style="font-size: 18px; margin-bottom: 5px;"></i>
                <span style="font-size: 9px; text-align: center; line-height: 1.1;">${item.name}</span>
            </div>
        `).join('');

                // Add click handlers
                grid.querySelectorAll('.icon-option').forEach(option => {
                    option.addEventListener('click', function () {
                        grid.querySelectorAll('.icon-option').forEach(o => o.classList.remove('selected'));
                        this.classList.add('selected');
                        selectedIcon = this.dataset.icon;
                    });
                });
            }

            // Apply button
            modal.querySelector('#applyIcon').addEventListener('click', function () {
                if (selectedIcon) {
                    applyCustomIcon(cell, selectedIcon);
                }
                modal.remove();
            });

            // Cancel button
            modal.querySelector('#cancelIcon').addEventListener('click', function () {
                modal.remove();
            });
        }


        function applyCustomIcon(cell, iconClass) {
            const currentText = cell.textContent.trim();
            cell.innerHTML = `
        <div style="text-align: center; display: flex; flex-direction: column; justify-content: center; height: 100%; padding: 6px;">
            <i class="${iconClass}" style="font-size: 24px; color: #3b82f6; display: block; margin-bottom: 6px;"></i>
            <div style="font-size: 11px; line-height: 1.2; font-weight: 600; color: #1e293b;">${currentText}</div>
        </div>
    `;
            cell.style.verticalAlign = 'middle';
            cell.style.textAlign = 'center';

            // Store the custom choice
            const cellKey = `${cell.closest('tr').dataset.row}-${Array.from(cell.parentElement.children).indexOf(cell)}`;
            customIconOverrides[cellKey] = iconClass;

            showStatus('Custom icon applied! Double-click any text cell to change its icon.', 'success');
        }

        // Modal functionality
        function initializeModal() {
            // Add event listener for the select agency button
            document.getElementById('selectAgencyBtn').addEventListener('click', function() {
                document.getElementById('strategyModal').classList.add('show');
                populateStrategyGrid();
            });

            // Modal close functionality
            document.getElementById('closeStrategyModal').addEventListener('click', function() {
                document.getElementById('strategyModal').classList.remove('show');
            });

            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const tabName = this.dataset.tab;

                    // Update tab buttons
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');

                    // Update tab content
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(tabName + '-tab').classList.add('active');
                });
            });

            // Filter functionality - auto-apply on change
            document.addEventListener('change', function(e) {
                if (e.target.matches('.filter-checkboxes input[type="checkbox"]')) {
                    applyFilters();
                }
            });

            document.getElementById('clearFilters').addEventListener('click', function() {
                document.querySelectorAll('.filter-checkboxes input[type="checkbox"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                applyFilters(); // Auto-apply after clearing
            });

            // CSV functionality
            document.getElementById('validateCsv').addEventListener('click', function() {
                const csvText = document.getElementById('csvInput').value.trim();
                if (!csvText) {
                    showStatus('Please paste your CSV data', 'error');
                    return;
                }

                try {
                    const result = parseCustomStrategy(csvText);
                    if (result.valid) {
                        // Update the insight table
                        updateInsightTable(result.content);

                        // Update selected display
                        document.querySelector('.selected-name').textContent = result.name;
                        document.querySelector('.selected-details').textContent = result.description;

                        // Close modal
                        document.getElementById('strategyModal').classList.remove('show');

                        showStatus('Custom strategy loaded successfully!', 'success');
                    } else {
                        showStatus(result.error, 'error');
                    }
                } catch (error) {
                    showStatus('Invalid CSV format. Please check your data.', 'error');
                }
            });

            document.getElementById('cancelCustom').addEventListener('click', function() {
                document.getElementById('csvInput').value = '';
                document.getElementById('strategyModal').classList.remove('show');
            });

            // Close modal on outside click
            document.getElementById('strategyModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    this.classList.remove('show');
                }
            });
        }

        // Populate strategy grid
        async function populateStrategyGrid() {
            const grid = document.getElementById('strategyGrid');

            // Show loading state
            grid.innerHTML = '<p style="text-align: center; color: #6b7280; grid-column: 1/-1;">Loading strategies...</p>';

            // Load metadata if not already loaded
            if (STRATEGY_PRESETS.length === 0) {
                const loaded = await loadStrategyMetadata();
                if (!loaded) {
                    grid.innerHTML = '<p style="text-align: center; color: #dc2626; grid-column: 1/-1;">Failed to load strategies</p>';
                    return;
                }
            }

            // Clear and populate grid
            grid.innerHTML = '';
            STRATEGY_PRESETS.forEach(strategy => {
                const card = createStrategyCard(strategy);
                grid.appendChild(card);
            });
        }

        function createStrategyCard(strategy) {
            const card = document.createElement('div');
            card.className = 'strategy-card';
            card.innerHTML = `
                <div class="strategy-card-left">
                    <div class="strategy-card-header">
                        <div class="strategy-title-section">
                            <h4 class="strategy-card-title">${strategy.name}</h4>
                            <p class="strategy-card-description">${strategy.description}</p>
                        </div>
                    </div>

                    <div class="strategy-value-section">
                        <div class="strategy-value-item">
                            <div class="strategy-value-label">
                                <i class="bi bi-people"></i>
                                Who is searching for this?
                            </div>
                            <div class="strategy-value-text">${strategy.whoSearches}</div>
                        </div>

                        <div class="strategy-value-item">
                            <div class="strategy-value-label">
                                <i class="bi bi-exclamation-circle"></i>
                                Why they need this now?
                            </div>
                            <div class="strategy-value-text">${strategy.whyNeeded}</div>
                        </div>

                        <div class="strategy-value-item">
                            <div class="strategy-value-label">
                                <i class="bi bi-star"></i>
                                Value delivered
                            </div>
                            <div class="strategy-value-text">${strategy.value}</div>
                        </div>
                    </div>
                </div>

                <div class="strategy-card-right">
                    <span class="strategy-category-badge">${strategy.category}</span>

                    <div class="strategy-card-tags">
                        <span class="strategy-tag price"><i class="bi bi-currency-dollar"></i> ${strategy.pricing}</span>
                        <span class="strategy-tag time"><i class="bi bi-clock"></i> ${strategy.speed}</span>
                        <span class="strategy-tag urgency">${getUrgencyBootstrapIcon(strategy.marketUrgency)} ${strategy.marketUrgency}</span>
                    </div>

                    <button class="strategy-select-btn" data-strategy-id="${strategy.id}">Select STAAAR</button>
                </div>
            `;

            // Add event listener for the select button
            const selectBtn = card.querySelector('.strategy-select-btn');
            selectBtn.addEventListener('click', () => selectStrategy(strategy.id));

            return card;
        }

        function getUrgencyIcon(urgency) {
            switch(urgency) {
                case 'HIGH': return 'ðŸ”´';
                case 'MEDIUM': return 'ðŸŸ¡';
                case 'LOW': return 'ðŸŸ¢';
                default: return 'ðŸŸ¡';
            }
        }

        function getUrgencyBootstrapIcon(urgency) {
            switch(urgency) {
                case 'HIGH': return '<i class="bi bi-exclamation-triangle-fill text-danger"></i>';
                case 'MEDIUM': return '<i class="bi bi-exclamation-diamond-fill text-warning"></i>';
                case 'LOW': return '<i class="bi bi-check-circle-fill text-success"></i>';
                default: return '<i class="bi bi-exclamation-diamond-fill text-warning"></i>';
            }
        }

        async function selectStrategy(strategyId) {
            const strategy = STRATEGY_PRESETS.find(s => s.id === strategyId);
            if (strategy) {
                // Show loading state
                showStatus('Loading strategy...', 'info');

                // Update the selected display
                const nameElement = document.querySelector('.selected-name');
                const detailsElement = document.querySelector('.selected-details');

                if (nameElement) nameElement.textContent = strategy.name;
                if (detailsElement) detailsElement.textContent = strategy.description;

                // Also update the floating title card
                const mainTitleElement = document.querySelector('.main-title');
                const subtitleElement = document.querySelector('.subtitle');
                if (mainTitleElement) mainTitleElement.textContent = strategy.name;
                if (subtitleElement) subtitleElement.textContent = strategy.description;

                // Load strategy content lazily
                const content = await loadStrategyContent(strategyId);
                if (content) {
                    // Update the insight table with strategy content
                    updateInsightTable(content);

                    // Close modal
                    document.getElementById('strategyModal').classList.remove('show');

                    showStatus(`Selected: ${strategy.name}`, 'success');
                } else {
                    showStatus('Failed to load strategy content', 'error');
                }
            }
        }

        function updateInsightTable(content) {
            console.log('ðŸ” DEBUG: updateInsightTable called with content:', content);

            const table = document.querySelector('.insight-table');
            if (!table) return;

            // Clear existing content
            table.innerHTML = '';

            console.log('ðŸ” DEBUG: About to render table with headers:', content.headers);
            console.log('ðŸ” DEBUG: About to render table with data rows:', content.data?.length);

            // Note: Title/description are already set by selectStrategy function using metadata values

            // Create rows that match the original table structure
            content.data.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                tr.setAttribute('data-row', rowIndex);

                // Add category cell (first column) - use headers from JSON
                const categoryCell = document.createElement('td');
                categoryCell.className = 'category-cell';

                // Use the header for this row if available
                const header = content.headers[rowIndex];
                console.log(`ðŸ” DEBUG: Row ${rowIndex} - Header:`, header);
                if (header && typeof header === 'object' && header.icon) {
                    console.log(`ðŸ” DEBUG: Row ${rowIndex} - Rendering icon: bi-${header.icon} for text: ${header.text}`);
                    categoryCell.innerHTML = `
                        <div style="text-align: center; display: flex; flex-direction: column; justify-content: center; height: 100%; padding: 6px;">
                            <i class="bi bi-${header.icon}" style="font-size: 24px; color: white; display: block; margin-bottom: 6px;"></i>
                            <div style="font-size: 11px; line-height: 1.2; font-weight: 600; color: white;">${header.text}</div>
                        </div>
                    `;
                } else if (header && typeof header === 'string') {
                    categoryCell.innerHTML = header;
                } else {
                    categoryCell.innerHTML = `ROW ${rowIndex + 1}<br>LEVEL`;
                }
                tr.appendChild(categoryCell);

                // Add image cell (second column)
                const imageCell = document.createElement('td');
                imageCell.className = 'image-cell';
                imageCell.innerHTML = `
                    <div class="image-placeholder" data-col="1">
                        <i class="bi bi-image"></i>
                    </div>
                `;
                tr.appendChild(imageCell);

                // Add text cells for each data column (these correspond to headers)
                row.forEach((cell, cellIndex) => {
                    console.log(`ðŸ” DEBUG: Row ${rowIndex}, Cell ${cellIndex} - Cell data:`, cell);
                    const td = document.createElement('td');
                    td.className = 'text-cell';

                    // Add header info as tooltip or data attribute for context
                    const header = content.headers[cellIndex];
                    if (header && typeof header === 'object') {
                        td.title = header.text;
                    }

                    console.log(`ðŸ” DEBUG: Row ${rowIndex}, Cell ${cellIndex} - Rendering icon: bi-${cell.icon} for text: ${cell.text}`);
                    // Use consistent large icon styling for all text cells
                    td.innerHTML = `
                        <div style="text-align: center; display: flex; flex-direction: column; justify-content: center; height: 100%; padding: 6px;">
                            <i class="bi bi-${cell.icon}" style="font-size: 24px; color: #3b82f6; display: block; margin-bottom: 6px;"></i>
                            <div style="font-size: 11px; line-height: 1.2; font-weight: 600; color: #1e293b;">${cell.text}</div>
                        </div>
                    `;

                    tr.appendChild(td);
                });

                table.appendChild(tr);
            });

            // Update Step 2 row buttons to match the new table
            setTimeout(() => {
                populateRowButtons();
            }, 100);

            // Note: Title and subtitle are now properly set by selectStrategy function
        }

        function parseCustomStrategy(csvText) {
            const lines = csvText.split('\n').filter(line => line.trim());

            if (lines.length < 3) {
                return { valid: false, error: 'Minimum 3 lines required (title + 2 data rows)' };
            }

            if (lines.length > 7) {
                return { valid: false, error: 'Maximum 7 lines allowed (title + 6 data rows)' };
            }

            // Parse title line
            const titleParts = lines[0].split(',');
            if (titleParts.length < 2) {
                return { valid: false, error: 'First line must contain: Title, Description' };
            }

            const name = titleParts[0].trim();
            const description = titleParts[1].trim();

            // Parse data lines
            const dataRows = [];
            const numCols = Math.floor(lines[1].split(',').length / 2); // icon,text pairs

            if (numCols < 4 || numCols > 6) {
                return { valid: false, error: 'Each row must have 4-6 columns (8-12 values as icon,text pairs)' };
            }

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(v => v.trim());
                if (values.length !== numCols * 2) {
                    return { valid: false, error: `Row ${i + 1} has incorrect number of values. Expected ${numCols * 2}, got ${values.length}` };
                }

                const row = [];
                for (let j = 0; j < values.length; j += 2) {
                    row.push({
                        icon: values[j],
                        text: values[j + 1]
                    });
                }
                dataRows.push(row);
            }

            // Generate headers
            const headers = [];
            for (let i = 0; i < numCols; i++) {
                headers.push(`COLUMN ${i + 1}`);
            }

            return {
                valid: true,
                name: name,
                description: description,
                content: {
                    headers: headers,
                    data: dataRows
                }
            };
        }

        function applyFilters() {
            // Get all checked filters by category
            const pricingFilters = Array.from(document.querySelectorAll('input[data-filter="pricing"]:checked')).map(cb => cb.value);
            const buyerFilters = Array.from(document.querySelectorAll('input[data-filter="buyer"]:checked')).map(cb => cb.value);
            const speedFilters = Array.from(document.querySelectorAll('input[data-filter="speed"]:checked')).map(cb => cb.value);
            const urgencyFilters = Array.from(document.querySelectorAll('input[data-filter="urgency"]:checked')).map(cb => cb.value);

            let filteredStrategies = STRATEGY_PRESETS;

            // Apply pricing filters
            if (pricingFilters.length > 0) {
                filteredStrategies = filteredStrategies.filter(strategy => {
                    return pricingFilters.includes(getIncomeLevel(strategy.pricing));
                });
            }

            // Apply buyer filters
            if (buyerFilters.length > 0) {
                filteredStrategies = filteredStrategies.filter(strategy => {
                    const categories = getBuyerCategories(strategy.whoSearches);
                    return buyerFilters.some(filter => categories.includes(filter));
                });
            }

            // Apply speed filters
            if (speedFilters.length > 0) {
                filteredStrategies = filteredStrategies.filter(strategy => {
                    return speedFilters.includes(getSpeedLevel(strategy.speed));
                });
            }

            // Apply urgency filters
            if (urgencyFilters.length > 0) {
                filteredStrategies = filteredStrategies.filter(strategy => {
                    return urgencyFilters.includes(strategy.marketUrgency);
                });
            }

            // Update grid with filtered results
            const grid = document.getElementById('strategyGrid');
            grid.innerHTML = '';

            filteredStrategies.forEach(strategy => {
                const card = createStrategyCard(strategy);
                grid.appendChild(card);
            });

            if (filteredStrategies.length === 0) {
                grid.innerHTML = '<p style="text-align: center; color: #6b7280; grid-column: 1/-1;">No strategies match your filters.</p>';
            }
        }


        // Initialize page with first strategy
        async function initializePageWithFirstStrategy() {
            console.log('ðŸ” DEBUG: initializePageWithFirstStrategy called');
            if (STRATEGY_PRESETS && STRATEGY_PRESETS.length > 0) {
                const firstStrategy = STRATEGY_PRESETS[0];
                console.log('ðŸ” DEBUG: First strategy on page load:', firstStrategy);

                // Update the selected display
                const nameElement = document.querySelector('.selected-name');
                const detailsElement = document.querySelector('.selected-details');
                if (nameElement) nameElement.textContent = firstStrategy.name;
                if (detailsElement) detailsElement.textContent = firstStrategy.description;

                // Update the floating title card
                const mainTitleElement = document.querySelector('.main-title');
                const subtitleElement = document.querySelector('.subtitle');
                if (mainTitleElement) mainTitleElement.textContent = firstStrategy.name;
                if (subtitleElement) subtitleElement.textContent = firstStrategy.description;

                // Load and display the first strategy content
                const content = await loadStrategyContent(firstStrategy.id);
                if (content) {
                    updateInsightTable(content);
                }
            }
        }

        // Initialize modal when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            initializeModal();

            // Preload strategy metadata for better performance
            await loadStrategyMetadata();

            // Initialize page with first strategy
            await initializePageWithFirstStrategy();

            // Ensure row buttons are populated (fallback in case of timing issues)
            setTimeout(() => {
                populateRowButtons();
            }, 500);
        });


        let selectedRow = null;
        let draggedElement = null;
        let isDragging = false;
        let watermarksEnabled = true; // Set to false for premium version

        let imageConnections = {}; // Track which text column each image connects to

        // Add this line
        toggleWatermarks(true); // Enable watermarks by default
        // Video handling
        const videoInput = document.getElementById('videoInput');
        const videoPlayer = document.getElementById('videoPlayer');
        // const screenshotBtn = document.getElementById('screenshotBtn');
        const status = document.getElementById('status');

        // Add global toast removal function
        window.removeToast = removeToast;

        // Global cropped images storage - single source of truth
        window.croppedImages = {};

        // Optimal rectangle dimensions for crisp presentation/PPT display
        const RECTANGLE_WIDTH = 1200;  // High quality for presentation clarity
        const RECTANGLE_HEIGHT = 800;  // 3:2 aspect ratio - works well for most content
        const RECTANGLE_ASPECT = RECTANGLE_WIDTH / RECTANGLE_HEIGHT;

        // Core Rectangle Cropping System - Single Source of Truth
        async function generateRectangleCrop(originalImageSrc, focusX = 0.5, focusY = 0.5) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Set standard rectangle dimensions
                    canvas.width = RECTANGLE_WIDTH;
                    canvas.height = RECTANGLE_HEIGHT;

                    // Calculate crop area for rectangle aspect ratio
                    const imgAspect = img.width / img.height;
                    let sourceWidth, sourceHeight, sourceX, sourceY;

                    if (imgAspect > RECTANGLE_ASPECT) {
                        // Image is wider - crop horizontally based on focus point
                        sourceHeight = img.height;
                        sourceWidth = img.height * RECTANGLE_ASPECT;
                        sourceY = 0;
                        sourceX = Math.max(0, Math.min(
                            (img.width - sourceWidth) * focusX,
                            img.width - sourceWidth
                        ));
                    } else {
                        // Image is taller - crop vertically based on focus point
                        sourceWidth = img.width;
                        sourceHeight = img.width / RECTANGLE_ASPECT;
                        sourceX = 0;
                        sourceY = Math.max(0, Math.min(
                            (img.height - sourceHeight) * focusY,
                            img.height - sourceHeight
                        ));
                    }

                    // Draw the cropped rectangle
                    ctx.drawImage(
                        img,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        0, 0, RECTANGLE_WIDTH, RECTANGLE_HEIGHT
                    );

                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = () => resolve(originalImageSrc); // Fallback
                img.src = originalImageSrc;
            });
        }

        // Update cropped image storage for a row
        async function updateCroppedImage(rowIndex, originalImageSrc, focusX = 0.5, focusY = 0.5) {
            const rowKey = `row-${rowIndex}`;
            console.log(`ðŸ”„ Generating rectangle crop for ${rowKey} at focus (${focusX.toFixed(2)}, ${focusY.toFixed(2)})`);

            const croppedImageUrl = await generateRectangleCrop(originalImageSrc, focusX, focusY);
            window.croppedImages[rowKey] = croppedImageUrl;

            console.log(`âœ… Stored rectangle crop for ${rowKey}`);
            return croppedImageUrl;
        }

        // Generate exact rectangle crop from specified coordinates
        async function generateExactRectangleCrop(originalImageSrc, rectLeft, rectTop, rectRight, rectBottom) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Set standard rectangle dimensions
                    canvas.width = RECTANGLE_WIDTH;
                    canvas.height = RECTANGLE_HEIGHT;

                    // Calculate source crop area from the rectangle coordinates
                    const sourceX = rectLeft * img.width;
                    const sourceY = rectTop * img.height;
                    const sourceWidth = (rectRight - rectLeft) * img.width;
                    const sourceHeight = (rectBottom - rectTop) * img.height;

                    console.log('ðŸ” Exact Crop Details:', {
                        originalSize: `${img.width}x${img.height}`,
                        sourceRect: `${sourceX.toFixed(0)},${sourceY.toFixed(0)} ${sourceWidth.toFixed(0)}x${sourceHeight.toFixed(0)}`,
                        outputSize: `${RECTANGLE_WIDTH}x${RECTANGLE_HEIGHT}`
                    });

                    // Draw the exact selected rectangle area
                    ctx.drawImage(
                        img,
                        sourceX, sourceY, sourceWidth, sourceHeight,
                        0, 0, RECTANGLE_WIDTH, RECTANGLE_HEIGHT
                    );

                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = () => resolve(originalImageSrc); // Fallback
                img.src = originalImageSrc;
            });
        }

        // Get stored cropped image or generate default
        function getCroppedImage(rowIndex) {
            const rowKey = `row-${rowIndex}`;
            return window.croppedImages[rowKey] || null;
        }

        // Initialize fixed 3:2 rectangle for PAN modal
        function initializeFixedRectangle() {
            const cropSelector = document.getElementById('cropSelector');
            const cropImage = document.getElementById('cropImage');

            if (!cropSelector || !cropImage) return;

            // Position rectangle in center of image initially
            const imageRect = cropImage.getBoundingClientRect();
            const imageContainer = cropImage.parentElement.getBoundingClientRect();

            // Calculate center position
            const centerX = (imageRect.width - 240) / 2; // 240px rectangle width
            const centerY = (imageRect.height - 160) / 2; // 160px rectangle height

            // Ensure rectangle stays within image bounds
            const maxX = Math.max(0, imageRect.width - 240);
            const maxY = Math.max(0, imageRect.height - 160);

            const initialX = Math.max(0, Math.min(centerX, maxX));
            const initialY = Math.max(0, Math.min(centerY, maxY));

            // Position the fixed rectangle
            cropSelector.style.left = initialX + 'px';
            cropSelector.style.top = initialY + 'px';

            // Make rectangle draggable (but not resizable)
            makeRectangleDraggable();

            console.log('âœ… Fixed 3:2 rectangle initialized at center');
        }

        // Make rectangle draggable within image bounds
        function makeRectangleDraggable() {
            const cropSelector = document.getElementById('cropSelector');
            const cropImage = document.getElementById('cropImage');
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            cropSelector.addEventListener('mousedown', function(e) {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                initialLeft = parseInt(cropSelector.style.left) || 0;
                initialTop = parseInt(cropSelector.style.top) || 0;
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                let newLeft = initialLeft + deltaX;
                let newTop = initialTop + deltaY;

                // Keep rectangle within image bounds
                const imageRect = cropImage.getBoundingClientRect();
                const containerRect = cropImage.parentElement.getBoundingClientRect();

                const maxLeft = imageRect.width - 240; // 240px rectangle width
                const maxTop = imageRect.height - 160; // 160px rectangle height

                newLeft = Math.max(0, Math.min(newLeft, maxLeft));
                newTop = Math.max(0, Math.min(newTop, maxTop));

                cropSelector.style.left = newLeft + 'px';
                cropSelector.style.top = newTop + 'px';
            });

            document.addEventListener('mouseup', function() {
                isDragging = false;
            });
        }

        if (videoInput) {
            videoInput.addEventListener('change', function (e) {
                const file = e.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    videoPlayer.src = url;
                    // screenshotBtn.disabled = false;
                    showStatus('Video loaded successfully!', 'success');
                }
            });
        }

        // Row selection with automatic frame capture
        // Note: Row button event listeners are now attached dynamically in attachRowButtonListeners()



        function captureFrame() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = videoPlayer.videoWidth;
            canvas.height = videoPlayer.videoHeight;

            ctx.drawImage(videoPlayer, 0, 0, canvas.width, canvas.height);

            if (watermarksEnabled) {
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(-Math.PI / 4);
                ctx.fillText('DEMO VERSION', -50, 0);
                ctx.restore();
            }

            const dataURL = canvas.toDataURL('image/png');

            // Find the image placeholder for the selected row
            const targetRow = document.querySelector(`tr[data-row="${selectedRow}"]`);
            const imagePlaceholder = targetRow.querySelector('.image-placeholder');

            // Remove existing content
            imagePlaceholder.innerHTML = '';

            // Add new image
            const img = document.createElement('img');
            img.src = dataURL;
            img.className = 'captured-image';
            img.draggable = false;
            img.dataset.mode = 'fit';
            img.dataset.originalSrc = dataURL;

            // Apply FIT styling by default - show complete image
            img.classList.add('fit-complete');
            img.style.objectFit = 'contain';
            img.style.objectPosition = 'center center';

            console.log(`âœ… Image captured in FIT mode - showing complete original for row ${selectedRow}`);

            // Add control buttons
            const controls = document.createElement('div');
            controls.className = 'image-controls';
            controls.innerHTML = `
        <button class="image-btn" data-mode="fit" title="Fit Complete Image"><i class="bi bi-arrows-fullscreen"></i></button>
        <button class="image-btn" data-mode="pan" title="Focus Area"><i class="bi bi-bullseye"></i></button>
        <button class="image-btn" data-mode="move" title="Move Image"><i class="bi bi-arrows-move"></i></button>
    `;

            // Add event listeners to control buttons
            controls.querySelectorAll('.image-btn').forEach(btn => {
                btn.addEventListener('click', function (e) {
                    e.stopPropagation();
                    handleImageMode(this.dataset.mode, img, controls, imagePlaceholder);
                });
            });

            imagePlaceholder.appendChild(img);
            imagePlaceholder.appendChild(controls);
            imagePlaceholder.classList.add('has-image');

            // Attach drag listeners to this new placeholder
            attachDragListeners(imagePlaceholder);

            showStatus(`Frame captured! Hover over image to see controls: FIT | FOCUS | MOVE`, 'success');

            // Set default connection to first text column with arrow
            const imageKey = `row-${selectedRow}`;
            imageConnections[imageKey] = 0;
            updateConnectionVisuals(selectedRow, 0);
        }

        // High-quality pan modal (no canvas degradation)
        let currentPanImage = null;
        let panScale = 1;
        let panTranslateX = 0;
        let panTranslateY = 0;

        function openPanModal(img) {
            currentPanImage = img;
            const modal = document.getElementById('cropModal');
            const cropImage = document.getElementById('cropImage');

            // Set the image source
            cropImage.src = img.dataset.originalSrc || img.src;

            // Change modal title for pan mode
            const modalTitle = modal.querySelector('h3');
            modalTitle.innerHTML = 'Select Focus Area';

            // Initialize fixed 3:2 rectangle selector
            const cropSelector = document.getElementById('cropSelector');
            cropSelector.style.display = 'block';

            // Wait for image to load, then set up fixed rectangle
            setTimeout(() => {
                initializeFixedRectangle();
            }, 100);

            // Reset pan values
            panScale = 1;
            panTranslateX = 0;
            panTranslateY = 0;

            modal.classList.add('show');

            // Set up event listeners for pan mode
            const confirmBtn = document.getElementById('confirmCrop');
            const cancelBtn = document.getElementById('cancelCrop');

            // Remove existing event listeners and add new ones
            confirmBtn.onclick = function() {
                // New rectangle cropping system
                const cropImage = document.getElementById('cropImage');
                const selector = document.getElementById('cropSelector');

                // Get selection coordinates
                const imageRect = cropImage.getBoundingClientRect();
                const selectorLeft = parseInt(selector.style.left);
                const selectorTop = parseInt(selector.style.top);
                const selectorWidth = parseInt(selector.style.width);
                const selectorHeight = parseInt(selector.style.height);

                // Calculate exact rectangle coordinates (0-1) for precise cropping
                const rectLeft = selectorLeft / imageRect.width;
                const rectTop = selectorTop / imageRect.height;
                const rectRight = (selectorLeft + selectorWidth) / imageRect.width;
                const rectBottom = (selectorTop + selectorHeight) / imageRect.height;

                console.log('ðŸŽ¯ Rectangle Coordinates:', {
                    left: rectLeft.toFixed(3),
                    top: rectTop.toFixed(3),
                    right: rectRight.toFixed(3),
                    bottom: rectBottom.toFixed(3),
                    width: (rectRight - rectLeft).toFixed(3),
                    height: (rectBottom - rectTop).toFixed(3)
                });

                // Get row index and original image source
                const rowIndex = parseInt(currentPanImage.closest('tr').dataset.row);
                const originalSrc = currentPanImage.dataset.originalSrc;

                // Generate exact rectangle crop from selected area
                generateExactRectangleCrop(originalSrc, rectLeft, rectTop, rectRight, rectBottom).then(croppedUrl => {
                    // Store the cropped image
                    const rowKey = `row-${rowIndex}`;
                    window.croppedImages[rowKey] = croppedUrl;

                    // Update image display
                    currentPanImage.src = croppedUrl;
                    currentPanImage.dataset.mode = 'pan';

                    console.log(`âœ… Applied EXACT PAN rectangle crop for row ${rowIndex}`);
                });

                // Close modal
                modal.classList.remove('show');
                showStatus('Focus area applied - rectangle crop generated!', 'success');
            };

            cancelBtn.onclick = function() {
                modal.classList.remove('show');
                // Reset crop selector visibility
                const cropSelector = document.getElementById('cropSelector');
                cropSelector.style.display = 'block';
                // Reset modal title
                const modalTitle = modal.querySelector('h3');
                modalTitle.innerHTML = 'Select Focus Area';
            };

            // Initialize area selection functionality after modal shows
            setTimeout(() => {
                initializePanSelector();
            }, 100);
        }

        function initializePanSelector() {
            const cropImage = document.getElementById('cropImage');
            const selector = document.getElementById('cropSelector');
            const imageRect = cropImage.getBoundingClientRect();

            // Get the target image holder aspect ratio to lock the selection rectangle
            const targetContainer = currentPanImage.parentElement;
            const targetAspectRatio = targetContainer.offsetWidth / targetContainer.offsetHeight;

            console.log('Debug PAN - Target aspect ratio:', targetAspectRatio);

            // Calculate initial selection size based on target aspect ratio
            // Start with 60% of image width, calculate height to match target ratio
            const initialWidth = imageRect.width * 0.6;
            const initialHeight = initialWidth / targetAspectRatio;

            // Center the selection
            const initialX = (imageRect.width - initialWidth) / 2;
            const initialY = (imageRect.height - initialHeight) / 2;

            selector.style.left = initialX + 'px';
            selector.style.top = initialY + 'px';
            selector.style.width = initialWidth + 'px';
            selector.style.height = initialHeight + 'px';

            // Make selector draggable and resizable with locked aspect ratio
            makePanSelectorInteractive(selector, cropImage, targetAspectRatio);
        }

        function makePanSelectorInteractive(selector, cropImage, lockedAspectRatio) {
            let isDragging = false;
            let isResizing = false;
            let startX, startY, startWidth, startHeight, startLeft, startTop;

            // Make the selector draggable
            selector.addEventListener('mousedown', function(e) {
                if (e.target === selector) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(selector.style.left);
                    startTop = parseInt(selector.style.top);
                    e.preventDefault();
                }
            });

            // Handle resize from corners/edges
            const handles = selector.querySelectorAll('.crop-handle');
            handles.forEach(handle => {
                handle.addEventListener('mousedown', function(e) {
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(selector.style.width);
                    startHeight = parseInt(selector.style.height);
                    startLeft = parseInt(selector.style.left);
                    startTop = parseInt(selector.style.top);
                    e.preventDefault();
                    e.stopPropagation();
                });
            });

            // Mouse move for dragging and resizing
            document.addEventListener('mousemove', function(e) {
                const imageRect = cropImage.getBoundingClientRect();

                if (isDragging) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;
                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;

                    // Keep within image bounds
                    newLeft = Math.max(0, Math.min(newLeft, imageRect.width - parseInt(selector.style.width)));
                    newTop = Math.max(0, Math.min(newTop, imageRect.height - parseInt(selector.style.height)));

                    selector.style.left = newLeft + 'px';
                    selector.style.top = newTop + 'px';
                }

                if (isResizing) {
                    const deltaX = e.clientX - startX;
                    let newWidth = startWidth + deltaX;

                    // Calculate height to maintain locked aspect ratio
                    let newHeight = newWidth / lockedAspectRatio;

                    // Apply minimum and maximum size constraints
                    const minWidth = 50;
                    const maxWidth = imageRect.width - startLeft;
                    const maxHeight = imageRect.height - startTop;

                    // Constrain by width
                    newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
                    newHeight = newWidth / lockedAspectRatio;

                    // If height is too big, constrain by height instead
                    if (newHeight > maxHeight) {
                        newHeight = maxHeight;
                        newWidth = newHeight * lockedAspectRatio;
                    }

                    selector.style.width = newWidth + 'px';
                    selector.style.height = newHeight + 'px';

                    // Update dimensions display
                    const dimensionsEl = selector.querySelector('#cropDimensions');
                    if (dimensionsEl) {
                        dimensionsEl.textContent = `${Math.round(newWidth)} x ${Math.round(newHeight)} (locked ratio)`;
                    }
                }
            });

            // Mouse up - stop dragging/resizing
            document.addEventListener('mouseup', function() {
                isDragging = false;
                isResizing = false;
            });
        }

        // Clean object-position approach - no transforms, no scaling
        function applyPan() {
            if (!currentPanImage) return;

            const cropImage = document.getElementById('cropImage');
            const selector = document.getElementById('cropSelector');

            // Get selection coordinates
            const imageRect = cropImage.getBoundingClientRect();
            const selectorLeft = parseInt(selector.style.left);
            const selectorTop = parseInt(selector.style.top);
            const selectorWidth = parseInt(selector.style.width);
            const selectorHeight = parseInt(selector.style.height);

            // Calculate the center of the selection as percentage of the modal image
            const centerXPercent = ((selectorLeft + selectorWidth/2) / imageRect.width) * 100;
            const centerYPercent = ((selectorTop + selectorHeight/2) / imageRect.height) * 100;

            console.log('ðŸŽ¯ PAN APPLY - Image Container:', {
                centerXPercent: centerXPercent.toFixed(1),
                centerYPercent: centerYPercent.toFixed(1),
                imageElement: currentPanImage.tagName,
                containerId: currentPanImage.id || 'no-id',
                containerSize: {
                    width: currentPanImage.parentElement.offsetWidth,
                    height: currentPanImage.parentElement.offsetHeight
                }
            });

            // Apply ONLY object-position - no transforms or scaling
            currentPanImage.style.objectFit = 'cover';
            currentPanImage.style.objectPosition = `${centerXPercent}% ${centerYPercent}%`;
            currentPanImage.style.transform = ''; // Ensure no transforms
            currentPanImage.style.transformOrigin = '';
            currentPanImage.style.scale = ''; // Ensure no scale
            currentPanImage.dataset.mode = 'pan';

            console.log('âœ… PAN APPLIED - Image Container Final Styles:', {
                objectFit: currentPanImage.style.objectFit,
                objectPosition: currentPanImage.style.objectPosition,
                transform: currentPanImage.style.transform,
                dataMode: currentPanImage.dataset.mode
            });

            // Store the positioning values for use in presentations and PowerPoint
            currentPanImage.dataset.panPositionX = centerXPercent;
            currentPanImage.dataset.panPositionY = centerYPercent;

            console.log('ðŸ”— PAN DATA - Stored ONLY on image element:', {
                imageElement: 'currentPanImage (IMG)',
                positionX: centerXPercent.toFixed(1) + '%',
                positionY: centerYPercent.toFixed(1) + '%',
                note: 'Video player remains unaffected'
            });

            // Close modal
            document.getElementById('cropModal').classList.remove('show');

            // Reset modal title
            const modalTitle = document.querySelector('#cropModal h3');
            modalTitle.innerHTML = 'Select Focus Area';

            showStatus('Focus area applied successfully with original quality preserved!', 'success');
        }

        function handleImageMode(mode, img, controls, placeholder) {
            // Update active button
            controls.querySelectorAll('.image-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });

            // Reset image classes and transforms
            img.classList.remove('fit-complete');
            img.style.transform = '';
            img.style.cursor = '';
            img.style.transformOrigin = '';
            img.style.objectPosition = ''; // Reset positioning from previous modes

            switch (mode) {
                case 'fit':
                    // FIT mode: Show complete original image (no cropping)
                    const originalSrc = img.dataset.originalSrc;
                    const rowIndex = parseInt(placeholder.closest('tr').dataset.row);

                    img.src = originalSrc; // Use original full image
                    img.dataset.mode = 'fit';

                    // Apply FIT styling - show complete image
                    img.classList.add('fit-complete');
                    img.style.objectFit = 'contain';
                    img.style.objectPosition = 'center center';

                    // Clear any stored rectangle crop for this row
                    const rowKey = `row-${rowIndex}`;
                    delete window.croppedImages[rowKey];

                    console.log(`âœ… Applied FIT mode - showing complete original for row ${rowIndex}`);
                    showStatus('FIT mode: Complete original image displayed', 'success');
                    break;

                case 'pan':
                    openPanModal(img);
                    showStatus('PAN mode: Adjust view and apply changes', 'success');
                    break;

                case 'move':
                    img.dataset.mode = 'move';
                    //console.log('Set image mode to move. Mode is now:', img.dataset.mode);
                    enableColumnDrag(placeholder);
                    showStatus('MOVE mode: Drag this column to reposition within the row', 'success');
                    break;
            }
        }

        // Crop Modal Functionality
        let currentCropImage = null;
        let cropData = { x: 0, y: 0, width: 200, height: 150 };

        function openCropModal(img) {
            currentCropImage = img;
            const modal = document.getElementById('cropModal');
            const cropImage = document.getElementById('cropImage');

            cropImage.src = img.dataset.originalSrc;
            modal.classList.add('show');

            // Initialize crop selector
            setTimeout(() => {
                initializeCropSelector();
            }, 100);
        }

        // Removed complex quality control functions - keeping it simple

        function initializeCropSelector() {
            const cropImage = document.getElementById('cropImage');
            const selector = document.getElementById('cropSelector');
            const imageRect = cropImage.getBoundingClientRect();

            // Set initial crop area (center 50%)
            const initialWidth = imageRect.width * 0.5;
            const initialHeight = imageRect.height * 0.5;
            const initialX = (imageRect.width - initialWidth) / 2;
            const initialY = (imageRect.height - initialHeight) / 2;

            selector.style.left = initialX + 'px';
            selector.style.top = initialY + 'px';
            selector.style.width = initialWidth + 'px';
            selector.style.height = initialHeight + 'px';

            cropData = { x: initialX, y: initialY, width: initialWidth, height: initialHeight };

            // Make selector draggable and resizable
            makeCropSelectorInteractive(selector, cropImage);
        }

        function makeCropSelectorInteractive(selector, cropImage) {
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let startX, startY, startWidth, startHeight, startLeft, startTop;

            function updateDimensions() {
                const width = parseInt(selector.style.width);
                const height = parseInt(selector.style.height);
                document.getElementById('cropDimensions').textContent = `${width} x ${height}`;
            }

            // Dragging the selector
            selector.addEventListener('mousedown', function (e) {
                if (e.target === selector) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startLeft = parseInt(selector.style.left);
                    startTop = parseInt(selector.style.top);
                    e.preventDefault();
                }
            });

            // Resizing handles
            selector.querySelectorAll('.crop-handle').forEach(handle => {
                handle.addEventListener('mousedown', function (e) {
                    isResizing = true;
                    resizeHandle = this.className.split(' ')[1]; // Get direction (nw, ne, etc.)
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = parseInt(selector.style.width);
                    startHeight = parseInt(selector.style.height);
                    startLeft = parseInt(selector.style.left);
                    startTop = parseInt(selector.style.top);
                    e.stopPropagation();
                    e.preventDefault();
                });
            });

            document.addEventListener('mousemove', function (e) {
                const imageRect = cropImage.getBoundingClientRect();

                if (isDragging) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newLeft = startLeft + deltaX;
                    let newTop = startTop + deltaY;

                    // Boundary checks
                    const selectorWidth = parseInt(selector.style.width);
                    const selectorHeight = parseInt(selector.style.height);

                    newLeft = Math.max(0, Math.min(newLeft, imageRect.width - selectorWidth));
                    newTop = Math.max(0, Math.min(newTop, imageRect.height - selectorHeight));

                    selector.style.left = newLeft + 'px';
                    selector.style.top = newTop + 'px';
                }

                if (isResizing && resizeHandle) {
                    const deltaX = e.clientX - startX;
                    const deltaY = e.clientY - startY;

                    let newLeft = startLeft;
                    let newTop = startTop;
                    let newWidth = startWidth;
                    let newHeight = startHeight;

                    // Handle different resize directions
                    switch (resizeHandle) {
                        case 'nw':
                            newLeft = startLeft + deltaX;
                            newTop = startTop + deltaY;
                            newWidth = startWidth - deltaX;
                            newHeight = startHeight - deltaY;
                            break;
                        case 'n':
                            newTop = startTop + deltaY;
                            newHeight = startHeight - deltaY;
                            break;
                        case 'ne':
                            newTop = startTop + deltaY;
                            newWidth = startWidth + deltaX;
                            newHeight = startHeight - deltaY;
                            break;
                        case 'w':
                            newLeft = startLeft + deltaX;
                            newWidth = startWidth - deltaX;
                            break;
                        case 'e':
                            newWidth = startWidth + deltaX;
                            break;
                        case 'sw':
                            newLeft = startLeft + deltaX;
                            newWidth = startWidth - deltaX;
                            newHeight = startHeight + deltaY;
                            break;
                        case 's':
                            newHeight = startHeight + deltaY;
                            break;
                        case 'se':
                            newWidth = startWidth + deltaX;
                            newHeight = startHeight + deltaY;
                            break;
                    }

                    // Enforce minimum size
                    const minSize = 30;
                    newWidth = Math.max(minSize, newWidth);
                    newHeight = Math.max(minSize, newHeight);

                    // Boundary checks
                    newLeft = Math.max(0, Math.min(newLeft, imageRect.width - newWidth));
                    newTop = Math.max(0, Math.min(newTop, imageRect.height - newHeight));
                    newWidth = Math.min(newWidth, imageRect.width - newLeft);
                    newHeight = Math.min(newHeight, imageRect.height - newTop);

                    selector.style.left = newLeft + 'px';
                    selector.style.top = newTop + 'px';
                    selector.style.width = newWidth + 'px';
                    selector.style.height = newHeight + 'px';

                    updateDimensions();
                }
            });

            document.addEventListener('mouseup', function () {
                isDragging = false;
                isResizing = false;
                resizeHandle = null;
            });

            // Initial dimension display
            updateDimensions();
        }

        // Crop Modal Event Listeners
        document.getElementById('confirmCrop').addEventListener('click', function () {
            applyCrop();
        });

        document.getElementById('cancelCrop').addEventListener('click', function () {
            document.getElementById('cropModal').classList.remove('show');
        });

        function applyCrop() {
            if (!currentCropImage) return;

            const cropImage = document.getElementById('cropImage');
            const selector = document.getElementById('cropSelector');

            // Get actual dimensions
            const imageRect = cropImage.getBoundingClientRect();
            const cropLeft = parseInt(selector.style.left);
            const cropTop = parseInt(selector.style.top);
            const cropWidth = parseInt(selector.style.width);
            const cropHeight = parseInt(selector.style.height);

            //console.log('Simple crop:', { cropLeft, cropTop, cropWidth, cropHeight });

            // Create a high-quality canvas - use the rectangle dimensions directly
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Use the rectangle dimensions for output (no need for separate quality controls)
            canvas.width = cropWidth;
            canvas.height = cropHeight;

            // Enable best quality
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Create an image element to draw from
            const sourceImg = new Image();
            sourceImg.onload = function () {
                // Calculate crop ratios
                const scaleX = sourceImg.naturalWidth / imageRect.width;
                const scaleY = sourceImg.naturalHeight / imageRect.height;

                // Calculate source crop coordinates
                const sourceX = cropLeft * scaleX;
                const sourceY = cropTop * scaleY;
                const sourceWidth = cropWidth * scaleX;
                const sourceHeight = cropHeight * scaleY;

                //console.log('Source crop coordinates:', { sourceX, sourceY, sourceWidth, sourceHeight });

                // Draw the cropped portion at full quality
                ctx.drawImage(
                    sourceImg,
                    sourceX, sourceY, sourceWidth, sourceHeight,  // Source crop area
                    0, 0, canvas.width, canvas.height             // Destination
                );

                // Apply the cropped image at maximum quality
                const croppedDataURL = canvas.toDataURL('image/png', 1.0);
                currentCropImage.src = croppedDataURL;
                currentCropImage.style.objectFit = 'cover';
                currentCropImage.style.objectPosition = '';
                currentCropImage.style.transform = '';
                currentCropImage.style.transformOrigin = '';

                //console.log('Crop applied with best quality');
                showStatus(`Perfect crop applied! (${cropWidth}x${cropHeight} at best quality)`, 'success');
            };

            sourceImg.src = currentCropImage.dataset.originalSrc;

            document.getElementById('cropModal').classList.remove('show');
        }

        function enableColumnDrag(placeholder) {
            //console.log('enableColumnDrag called for placeholder:', placeholder);

            placeholder.style.cursor = 'grab';
            placeholder.style.border = '2px dashed #4CAF50';

            const img = placeholder.querySelector('.captured-image');
            if (img) {
                img.dataset.mode = 'move';
                // //console.log('Set image mode to move in enableColumnDrag. Mode is now:', img.dataset.mode);
            }

            // Show visual feedback that it's draggable
            placeholder.style.cursor = 'grab';

            setTimeout(() => {
                placeholder.style.border = '';
                // Keep cursor as grab to show it's still draggable
            }, 3000);
        }

        // Drag and drop functionality for repositioning columns
        const imagePlaceholders = document.querySelectorAll('.image-placeholder');
        let dragStartX, dragStartY;
        let draggedCell, originalRow;


        // Global mouse events for drag and drop
        document.addEventListener('mousemove', function (e) {
            if (isDragging && draggedElement) {
                e.preventDefault();
                draggedElement.style.transform = `translate(${e.clientX - dragStartX}px, ${e.clientY - dragStartY}px)`;

                // Highlight current drop target
                const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
                const targetCell = elementBelow ? elementBelow.closest('td') : null;

                //console.log('Mouse move - elementBelow:', elementBelow);
                //console.log('Mouse move - targetCell:', targetCell);
                //console.log('Mouse move - originalRow exists:', !!originalRow);
                // Reset highlights
                // Only highlight the current hover target - don't reset all cells every time
                if (originalRow) {
                    const allCells = originalRow.querySelectorAll('td:not(.category-cell)');
                    allCells.forEach(cell => {
                        if (cell !== draggedCell) {
                            cell.style.backgroundColor = '';
                            cell.style.border = '';
                        }
                    });

                    // Highlight only the current target
                    if (targetCell && targetCell !== draggedCell &&
                        targetCell.parentElement === originalRow &&
                        !targetCell.classList.contains('category-cell')) {
                        targetCell.style.backgroundColor = 'rgba(255, 193, 7, 0.4)';
                        targetCell.style.border = '2px solid #FF9800';
                        //console.log('Highlighting target:', targetCell);
                    }
                }
            }
        });

        document.addEventListener('mouseup', function (e) {
            if (isDragging && draggedElement && draggedCell) {
                e.preventDefault();

                // Reset visual styles
                draggedElement.style.transform = '';
                draggedElement.style.opacity = '1';
                draggedElement.style.cursor = 'move';
                draggedElement.style.zIndex = '';
                draggedElement.style.position = '';

                // Find valid drop target
                const targetCell = getValidDropTarget(e, originalRow);

                //console.log('Dropped on cell:', targetCell);
                //console.log('Original cell:', draggedCell);

                if (targetCell && targetCell !== draggedCell) {
                    // Reorder the columns
                    reorderColumns(draggedCell, targetCell);
                    showStatus('Column moved to new position - other columns shifted automatically!', 'success');
                } else {
                    showStatus('Drop on another valid column position (not the last one)', 'error');
                }

                // Reset all highlights
                const allCells = originalRow.querySelectorAll('td');
                allCells.forEach(cell => {
                    cell.style.backgroundColor = '';
                    cell.style.border = '';
                });

                isDragging = false;
                draggedElement = null;
                draggedCell = null;
                originalRow = null;
            }
        });

        // Function to attach drag listeners to a placeholder
        function attachDragListeners(placeholder) {
            //console.log('Attaching drag listeners to placeholder:', placeholder);

            placeholder.addEventListener('mousedown', function (e) {
                //console.log('Mousedown on placeholder. Target:', e.target);
                //console.log('Has image class:', this.classList.contains('has-image'));

                // Special handling for MOVE button - let it set the mode first
                if (e.target.classList.contains('image-btn') && e.target.dataset.mode === 'move') {
                    //console.log('MOVE button clicked - waiting for mode to be set');
                    // Let the button handler run first, then enable dragging
                    setTimeout(() => {
                        //console.log('Now enabling drag mode');
                        const img = this.querySelector('.captured-image');
                        if (img && img.dataset.mode === 'move') {
                            //console.log('Image is now in move mode, drag enabled');
                            this.style.cursor = 'grab';
                        }
                    }, 10);
                    return;
                }

                // Don't start dragging if clicking on other control buttons
                if (e.target.classList.contains('image-btn')) {
                    //console.log('Clicked on non-MOVE image button, returning');
                    return;
                }

                // Only start dragging if we have an image and it's in move mode
                if (this.classList.contains('has-image')) {
                    const img = this.querySelector('.captured-image');
                    //console.log('Found image:', img);
                    //console.log('Image mode:', img ? img.dataset.mode : 'no image');

                    if (!img || img.dataset.mode !== 'move') {
                        //console.log('Image not in move mode, returning');
                        return;
                    }

                    //console.log('Starting drag operation');
                    e.preventDefault();
                    isDragging = true;
                    draggedElement = this;
                    draggedCell = this.parentElement;
                    originalRow = draggedCell.parentElement;

                    dragStartX = e.clientX;
                    dragStartY = e.clientY;

                    this.style.opacity = '0.7';
                    this.style.cursor = 'grabbing';
                    this.style.zIndex = '1000';
                    this.style.position = 'relative';

                    showStatus('Drag to reposition this column - drop on target position, others will shift left', 'success');
                }
            });
        }

        // Attach listeners to existing placeholders
        document.querySelectorAll('.image-placeholder').forEach(attachDragListeners);



        function reorderColumns(sourceCell, targetCell) {
            const row = sourceCell.parentElement;
            const allCells = Array.from(row.querySelectorAll('td:not(.category-cell)'));

            const sourceIndex = allCells.indexOf(sourceCell);
            const targetIndex = allCells.indexOf(targetCell);

            //console.log(`Moving column from position ${sourceIndex} to position ${targetIndex}`);

            // Calculate the new text column index for the image
            // Since image is always in position 0 (after category),
            // the connected text column will be at targetIndex
            const rowIndex = parseInt(sourceCell.closest('tr').dataset.row);
            const imageKey = `row-${rowIndex}`;

            // Store the new connection before DOM manipulation
            const newTextColumnIndex = targetIndex;

            // Remove source cell from its current position
            sourceCell.remove();

            // Insert it at the target position - FIXED LOGIC
            if (targetIndex === 0) {
                // Insert at the beginning (after category cell)
                const categoryCell = row.querySelector('.category-cell');
                row.insertBefore(sourceCell, categoryCell.nextSibling);
            } else {
                // Insert before the target cell (which is now at targetIndex - 1 due to removal)
                const remainingCells = Array.from(row.querySelectorAll('td:not(.category-cell)'));
                if (targetIndex >= remainingCells.length) {
                    // Insert at the end
                    row.appendChild(sourceCell);
                } else {
                    row.insertBefore(sourceCell, remainingCells[targetIndex]);
                }
            }

            // Update the connection mapping - FIXED CONNECTION UPDATE
            imageConnections[imageKey] = newTextColumnIndex;
            updateConnectionVisuals(rowIndex, newTextColumnIndex);

            //console.log(`Column reordered successfully. New connection: text column ${newTextColumnIndex}`);
        }


        // Download functionality
        const downloadBtn = document.getElementById('downloadBtn');
        downloadBtn.addEventListener('click', function () {
            openDownloadModal();
        });

        function openDownloadModal() {
            const modal = document.getElementById('downloadModal');
            const previewVideo = document.getElementById('previewVideo');
            const mapPreview = document.getElementById('mapPreview');

            // Copy video source
            previewVideo.src = videoPlayer.src;

            // Video should show FULL thumbnail - use 'contain' to show complete video
            previewVideo.style.objectFit = 'contain';
            previewVideo.style.objectPosition = 'center center';

            console.log('ðŸ“º PRESENTATION VIDEO - Full Thumbnail:', {
                videoElement: 'previewVideo (first page)',
                objectFit: 'contain (shows full video)',
                positioning: 'center center',
                note: 'Shows complete video with letterboxing if needed'
            });

            // Clone map content for overview slide
            const mapSection = document.querySelector('.map-section');
            mapPreview.innerHTML = mapSection.innerHTML;

            // Clean up overview slide
            mapPreview.querySelectorAll('.image-controls').forEach(control => {
                control.remove();
            });
            mapPreview.querySelectorAll('.row-highlight').forEach(highlight => {
                highlight.classList.remove('row-highlight');
            });
            const downloadSection = mapPreview.querySelector('.download-section-centered');
            if (downloadSection) downloadSection.remove();
            mapPreview.querySelectorAll('*').forEach(element => {
                element.style.outline = 'none';
                element.style.border = element.style.border.replace(/green/gi, 'transparent');
            });
            mapPreview.querySelectorAll('.text-cell').forEach(cell => {
                cell.classList.remove('icon-customizable');
                cell.style.cursor = 'default';
                cell.style.border = 'none';
            });

            // Recreate arrows for overview
            mapPreview.querySelectorAll('.connection-arrow').forEach(arrow => {
                arrow.remove();
            });

            setTimeout(() => {
                Object.keys(imageConnections).forEach(key => {
                    const rowIndex = parseInt(key.split('-')[1]);
                    const textColumnIndex = imageConnections[key];
                    recreateArrowForPreview(mapPreview, rowIndex, textColumnIndex);
                });

                // Generate individual row slides
                generateRowSlides();

                // Initialize simple slide navigation after slides are generated
                setTimeout(() => {
                    // Make sure slides are actually created before initializing navigation
                    const slides = document.querySelectorAll('.simple-slide');
                    console.log('Slides found during initialization:', slides.length);

                    if (slides.length > 0) {
                        initializeSlideNavigation();
                        console.log('âœ… Slide navigation initialized with', slides.length, 'total slides');
                    } else {
                        console.error('âŒ No slides found! Cannot initialize navigation');
                    }
                }, 200);
            }, 100);

            modal.classList.add('show');
        }

        // Add this new function to recreate arrows specifically for preview
        function recreateArrowForPreview(previewContainer, rowIndex, textColumnIndex) {
            const targetRow = previewContainer.querySelector(`tr[data-row="${rowIndex}"]`);
            if (!targetRow) return;

            const imagePlaceholder = targetRow.querySelector('.image-placeholder');
            const textCells = targetRow.querySelectorAll('.text-cell');

            if (imagePlaceholder && textCells[textColumnIndex]) {
                // Add connection classes
                imagePlaceholder.classList.add('connected-pair');
                textCells[textColumnIndex].classList.add('connected-pair');

                // Create arrow for preview
                const table = previewContainer.querySelector('.insight-table');
                const sourceRect = imagePlaceholder.getBoundingClientRect();
                const targetRect = textCells[textColumnIndex].getBoundingClientRect();
                const tableRect = table.getBoundingClientRect();

                const startX = sourceRect.right - tableRect.left;
                const startY = (sourceRect.top + sourceRect.height / 2) - tableRect.top;
                const endX = targetRect.left - tableRect.left;
                const length = endX - startX - 4;

                const arrow = document.createElement('div');
                arrow.className = 'connection-arrow';
                arrow.style.left = (startX + 2) + 'px';
                arrow.style.top = startY + 'px';
                arrow.style.width = length + 'px';
                arrow.style.height = '3px';
                arrow.style.opacity = '1';
                arrow.style.transform = 'translateY(-50%)';

                table.appendChild(arrow);
            }
        }

        // Row data for slides
        const rowData = [
            { name: 'BUYER ACTIONS', class: '', color: '#475569' },
            { name: 'BUYER BARRIERS', class: 'barriers', color: '#0ea5e9' },
            { name: 'BUYER PERCEPTIONS', class: 'perceptions', color: '#8b5cf6' },
            { name: 'BUYER GOALS', class: 'goals', color: '#06b6d4' },
            { name: 'BUYER DRIVERS', class: 'drivers', color: '#10b981' },
            { name: 'BUYER MINDSET', class: 'mindset', color: '#f59e0b' }
        ];

        function generateRowSlides() {
            const slidesContainer = document.querySelector('#slidesContainer');
            console.log('ðŸ”„ Generating row slides...');

            if (!slidesContainer) {
                console.error('âŒ Slides container not found');
                return;
            }

            // Clear existing row slides (keep only the overview slide)
            const existingSlides = slidesContainer.querySelectorAll('.slide-row-detail');
            existingSlides.forEach(slide => slide.remove());
            console.log(`ðŸ—‘ï¸ Removed ${existingSlides.length} existing detail slides`);

            // Check if there are any rows in the table at all
            const allRows = document.querySelectorAll('tr[data-row]');
            console.log(`ðŸ—ï¸ Found ${allRows.length} total rows in table`);

            // Generate slides for each row
            console.log(`ðŸ“‹ Generating ${rowData.length} row slides`);
            rowData.forEach((row, index) => {
                const targetRow = document.querySelector(`tr[data-row="${index}"]`);
                console.log(`ðŸ” Looking for row ${index}:`, targetRow ? 'Found' : 'NOT FOUND');

                // Generate slide even if row is not found (fallback)
                const shouldGenerate = true; // Always generate for now
                if (!targetRow && shouldGenerate) {
                    console.warn(`âš ï¸ Row ${index} not found, generating placeholder slide`);
                }

                const imagePlaceholder = targetRow ? targetRow.querySelector('.image-placeholder') : null;
                const textCells = targetRow ? targetRow.querySelectorAll('.text-cell') : [];

                console.log(`ðŸ“¸ Row ${index} - Image placeholder:`, imagePlaceholder ? 'Found' : 'NOT FOUND');
                console.log(`ðŸ“ Row ${index} - Text cells:`, textCells.length);

                // Get connected text column index
                const imageKey = `row-${index}`;
                const connectedColumnIndex = imageConnections[imageKey] || 0;
                console.log(`ðŸ”— Row ${index} - Connected to column:`, connectedColumnIndex);

                // Create slide HTML
                const slide = document.createElement('div');
                slide.className = 'simple-slide slide-row-detail';
                console.log(`ðŸŽ¬ Creating slide for row ${index}`);

                // Generate context items (other progression steps)
                let contextItems = '';
                if (textCells && textCells.length > 0) {
                    contextItems = Array.from(textCells).map((cell, cellIndex) => {
                        if (cellIndex !== connectedColumnIndex) {
                            return `<span class="slide-context-item">${getTextContent(cell)}</span>`;
                        }
                        return '';
                    }).filter(item => item).join('');
                } else {
                    console.warn(`âš ï¸ No text cells found for row ${index}, using placeholder`);
                    contextItems = '<span class="slide-context-item">No context available</span>';
                }

                slide.innerHTML = `
                    <div class="slide-titles-section" style="grid-column: 1 / -1; margin-bottom: 20px;">
                        <div class="slide-overall-title" style="text-align: center; font-size: 28px; font-weight: 800; color: #1e293b; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 12px;">
                            BUYER INSIGHT MAP
                        </div>
                        <div class="slide-category-title" style="background: ${row.color}; text-align: center; padding: 12px 24px; border-radius: 8px; font-size: 18px; font-weight: 600; color: white;">
                            ${row.name}
                        </div>
                    </div>

                    <div class="slide-image-section">
                        ${imagePlaceholder && imagePlaceholder.classList.contains('has-image') ? (() => {
                            const originalImage = imagePlaceholder.querySelector('.captured-image');
                            if (!originalImage) {
                                return '<div class="slide-no-image">No image captured</div>';
                            }
                            const currentMode = originalImage.dataset.mode;

                            if (currentMode === 'pan') {
                                // PAN mode: Use stored rectangle crop
                                const storedCroppedImage = getCroppedImage(index);
                                const imageSource = storedCroppedImage || originalImage.src;
                                return `<img src="${imageSource}" class="slide-large-image" alt="${row.name}" style="object-fit: cover; object-position: center;">`;
                            } else {
                                // FIT mode: Use original image with contain
                                return `<img src="${originalImage.src}" class="slide-large-image" alt="${row.name}" style="object-fit: contain; object-position: center;">`;
                            }
                        })() :
                            `<div class="slide-image-placeholder">
                                <i class="bi bi-image" style="font-size: 48px; color: #64748b;"></i>
                                <div class="slide-image-placeholder-text">No Scene Capture Yet</div>
                            </div>`
                        }
                        <div class="slide-image-caption">
                            ${imagePlaceholder && imagePlaceholder.classList.contains('has-image') ? 'Video Frame Capture' : 'Scene on Focus'}
                        </div>
                    </div>

                    <div class="slide-details-section">
                        <div class="slide-connected-highlight">
                            <div class="slide-connected-badge">LINKED STEP</div>
                            <div class="slide-connected-text">
                                ${textCells[connectedColumnIndex] ? getTextContent(textCells[connectedColumnIndex]) : 'No connection established'}
                            </div>
                        </div>

                        <div class="slide-context-section">
                            <div class="slide-context-label">Other progression steps</div>
                            <div class="slide-context-items">
                                ${contextItems}
                            </div>
                        </div>

                        <div class="slide-text-input-box">
                            <div class="slide-input-label">Your custom content</div>
                            <textarea
                                class="slide-input-textarea"
                                placeholder="Add your insights, analysis, or custom content here...

This text box is ready for your PowerPoint or Keynote presentation.
Simply download the slide and paste your content directly into this area."
                            ></textarea>
                            <div class="slide-input-instructions">Perfect for copy-paste into presentation software</div>
                        </div>
                    </div>
                `;

                slidesContainer.appendChild(slide);
                console.log(`âœ… Created slide ${index + 1} for ${row.name}`);
            });

            // Final count verification
            const totalCreated = slidesContainer.querySelectorAll('.simple-slide').length;
            console.log(`ðŸŽ¯ Total slides in container: ${totalCreated} (1 overview + ${rowData.length} details)`);
        }

        function getTextContent(cell) {
            // Extract text content from cell, handling both icon and plain text cells
            const textDiv = cell.querySelector('div > div');
            return textDiv ? textDiv.textContent.trim() : cell.textContent.trim();
        }

        // Copy slide content to clipboard
        function copySlideContent(slideIndex) {
            const contentElement = document.getElementById(`slide-content-${slideIndex}`);
            if (contentElement) {
                const text = contentElement.textContent;

                // Try to copy to clipboard
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        showStatus('Content copied to clipboard!', 'success');

                        // Visual feedback on button
                        const button = event.target;
                        const originalText = button.textContent;
                        button.textContent = 'âœ“ COPIED';
                        button.style.background = '#10b981';

                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = '#3b82f6';
                        }, 2000);
                    }).catch(() => {
                        fallbackCopyMethod(text);
                    });
                } else {
                    fallbackCopyMethod(text);
                }
            }
        }

        // Fallback copy method for older browsers
        function fallbackCopyMethod(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
                showStatus('Content copied to clipboard!', 'success');
            } catch (err) {
                showStatus('Could not copy text. Please select and copy manually.', 'error');
            }

            document.body.removeChild(textArea);
        }

        let currentSlideIndex = 0;
        let totalSlides = 0;

        function initializeSlideNavigation() {
            const slides = document.querySelectorAll('.simple-slide');
            totalSlides = slides.length;

            // Update counter
            updateSlideCounter();

            // Add event listeners
            document.getElementById('prevSlide').addEventListener('click', previousSlide);
            document.getElementById('nextSlide').addEventListener('click', nextSlide);

            // Add keyboard navigation
            document.addEventListener('keydown', handleKeyboard);

            // Update navigation buttons
            updateNavigationButtons();

            console.log('Simple slide navigation initialized with', totalSlides, 'slides');
        }

        function showSlide(index) {
            const slides = document.querySelectorAll('.simple-slide');

            // Hide all slides
            slides.forEach(slide => slide.classList.remove('active'));

            // Show current slide
            if (slides[index]) {
                slides[index].classList.add('active');
                currentSlideIndex = index;
                updateSlideCounter();
                updateNavigationButtons();
            }
        }

        function nextSlide() {
            if (currentSlideIndex < totalSlides - 1) {
                showSlide(currentSlideIndex + 1);
            }
        }

        function previousSlide() {
            if (currentSlideIndex > 0) {
                showSlide(currentSlideIndex - 1);
            }
        }

        function updateSlideCounter() {
            const counter = document.getElementById('slideCounter');
            if (counter) {
                counter.textContent = `${currentSlideIndex + 1} / ${totalSlides}`;
            }
        }

        function updateNavigationButtons() {
            const prevBtn = document.getElementById('prevSlide');
            const nextBtn = document.getElementById('nextSlide');

            if (prevBtn) prevBtn.disabled = currentSlideIndex === 0;
            if (nextBtn) nextBtn.disabled = currentSlideIndex === totalSlides - 1;
        }

        function handleKeyboard(event) {
            if (document.getElementById('downloadModal').classList.contains('show')) {
                switch(event.key) {
                    case 'ArrowLeft':
                        previousSlide();
                        break;
                    case 'ArrowRight':
                        nextSlide();
                        break;
                }
            }
        }

        // Download modal event listeners
        document.getElementById('downloadCurrentSlide').addEventListener('click', function () {
            downloadCurrentSlide();
        });

        document.getElementById('downloadAllSlides').addEventListener('click', function () {
            downloadAllSlides();
        });

        document.getElementById('downloadPPT').addEventListener('click', function () {
            console.log('PptxGenJS available:', typeof PptxGenJS !== 'undefined');
            downloadAsPowerPoint();
        });

        document.getElementById('cancelDownload').addEventListener('click', function () {
            document.getElementById('downloadModal').classList.remove('show');
            // Reset to first slide
            currentSlideIndex = 0;
            showSlide(0);
        });

        function downloadCurrentSlide() {
            const activeSlide = document.querySelector('.simple-slide.active');
            const slideIndex = currentSlideIndex;

            html2canvas(activeSlide, {
                backgroundColor: '#ffffff',
                scale: 2,
                useCORS: true,
                width: 1920,
                height: 1080,
                windowWidth: 1920,
                windowHeight: 1080
            }).then(canvas => {
                const link = document.createElement('a');
                const slideName = slideIndex === 0 ? 'overview' : `row-${slideIndex}-${rowData[slideIndex - 1]?.name.toLowerCase().replace(/\s+/g, '-') || 'unknown'}`;
                link.download = `buyer-insight-slide-${slideName}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();

                showStatus(`Current slide downloaded! (1920x1080)`, 'success');
            });
        }

        async function downloadAllSlides() {
            const slides = document.querySelectorAll('.simple-slide');
            const totalSlides = slides.length;
            const zip = new JSZip();

            showStatus(`Creating ZIP with ${totalSlides} slides...`, 'success');

            try {
                // Store current active slide
                const currentActiveSlide = document.querySelector('.simple-slide.active');

                // Process all slides and add to ZIP
                for (let index = 0; index < slides.length; index++) {
                    const slide = slides[index];

                    // Temporarily make this slide visible for capture
                    slides.forEach(s => s.classList.remove('active'));
                    slide.classList.add('active');

                    // Handle video capture properly
                    const videos = slide.querySelectorAll('video');
                    const videoPlaceholders = [];

                    for (let video of videos) {
                        try {
                            // Try to capture video thumbnail for first slide (overview)
                            if (index === 0 && video.readyState >= 2) {
                                // Create canvas to capture video frame
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                canvas.width = video.videoWidth || 640;
                                canvas.height = video.videoHeight || 360;

                                try {
                                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                                    // Create image element with captured frame
                                    const thumbnail = document.createElement('img');
                                    thumbnail.src = canvas.toDataURL('image/png');

                                    // Calculate optimal thumbnail dimensions based on video aspect ratio
                                    const videoWidth = video.videoWidth || 640;
                                    const videoHeight = video.videoHeight || 360;
                                    const videoAspectRatio = videoWidth / videoHeight;
                                    const isVertical = videoAspectRatio < 1; // Vertical if height > width
                                    const maxContainerWidth = 400; // Maximum width for the container
                                    const maxContainerHeight = 380; // Maximum height for the container

                                    let thumbnailWidth, thumbnailHeight;

                                    if (isVertical) {
                                        // For vertical videos, prioritize height and calculate width
                                        thumbnailHeight = Math.min(maxContainerHeight, videoHeight);
                                        thumbnailWidth = thumbnailHeight * videoAspectRatio;
                                    } else {
                                        // For horizontal videos, prioritize width and calculate height
                                        thumbnailWidth = Math.min(maxContainerWidth, videoWidth);
                                        thumbnailHeight = thumbnailWidth / videoAspectRatio;
                                    }

                                    // Apply dimensions that match the video's natural aspect ratio
                                    thumbnail.style.width = thumbnailWidth + 'px';
                                    thumbnail.style.height = thumbnailHeight + 'px';
                                    thumbnail.style.objectFit = 'cover'; // Use cover to fill the exact dimensions
                                    thumbnail.style.objectPosition = 'center';
                                    thumbnail.style.borderRadius = '8px';
                                    thumbnail.style.background = '#000';
                                    thumbnail.style.display = 'block';
                                    thumbnail.style.margin = '0 auto'; // Center the thumbnail
                                    thumbnail.className = 'video-thumbnail-temp';

                                    // Store dimensions and aspect ratio information
                                    thumbnail.setAttribute('data-original-width', videoWidth);
                                    thumbnail.setAttribute('data-original-height', videoHeight);
                                    thumbnail.setAttribute('data-aspect-ratio', videoAspectRatio);
                                    thumbnail.setAttribute('data-is-vertical', isVertical);
                                    thumbnail.setAttribute('data-thumbnail-width', thumbnailWidth);
                                    thumbnail.setAttribute('data-thumbnail-height', thumbnailHeight);

                                    video.style.display = 'none';
                                    video.parentNode.insertBefore(thumbnail, video);
                                    videoPlaceholders.push({ video, placeholder: thumbnail });
                                } catch (e) {
                                    // Fallback to placeholder if thumbnail capture fails
                                    throw e;
                                }
                            } else {
                                throw new Error('Use placeholder');
                            }
                        } catch (e) {
                            // Use placeholder for videos that can't be captured
                            const placeholder = document.createElement('div');
                            placeholder.style.width = video.style.width || '100%';
                            placeholder.style.height = video.style.height || 'auto';
                            placeholder.style.minHeight = '200px';
                            placeholder.style.background = '#000';
                            placeholder.style.borderRadius = video.style.borderRadius || '8px';
                            placeholder.style.display = 'flex';
                            placeholder.style.alignItems = 'center';
                            placeholder.style.justifyContent = 'center';
                            placeholder.style.color = 'white';
                            placeholder.style.fontSize = '14px';
                            placeholder.innerHTML = 'â–¶ Video Content';
                            placeholder.className = 'video-placeholder-temp';

                            video.style.display = 'none';
                            video.parentNode.insertBefore(placeholder, video);
                            videoPlaceholders.push({ video, placeholder });
                        }
                    }

                    // Wait a moment for rendering
                    await new Promise(resolve => setTimeout(resolve, 200));

                    // Get the actual slide dimensions
                    const slideRect = slide.getBoundingClientRect();
                    const actualWidth = slideRect.width;
                    const actualHeight = slideRect.height;

                    const canvas = await html2canvas(slide, {
                        backgroundColor: '#ffffff',
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        foreignObjectRendering: false,
                        ignoreElements: function(element) {
                            // Skip video elements as they cause taint issues
                            return element.tagName === 'VIDEO';
                        },
                        width: actualWidth,
                        height: actualHeight,
                        scrollX: 0,
                        scrollY: 0,
                        onclone: function(clonedDoc) {
                            // Ensure videos and images maintain aspect ratio in clone
                            const images = clonedDoc.querySelectorAll('img');
                            images.forEach(img => {
                                // Preserve original styling
                                img.style.objectFit = 'contain';
                                img.style.maxWidth = '100%';
                                img.style.height = 'auto';
                            });

                            // Handle video thumbnails specifically with aspect ratio preservation
                            const videoThumbnails = clonedDoc.querySelectorAll('.video-thumbnail-temp');
                            videoThumbnails.forEach(thumb => {
                                // Get stored dimension information
                                const thumbnailWidth = thumb.getAttribute('data-thumbnail-width');
                                const thumbnailHeight = thumb.getAttribute('data-thumbnail-height');
                                const isVertical = thumb.getAttribute('data-is-vertical') === 'true';
                                const aspectRatio = thumb.getAttribute('data-aspect-ratio');

                                // Ensure exact dimensions are maintained
                                thumb.style.width = thumbnailWidth + 'px';
                                thumb.style.height = thumbnailHeight + 'px';
                                thumb.style.objectFit = 'cover'; // Use cover to maintain exact aspect ratio
                                thumb.style.objectPosition = 'center';
                                thumb.style.display = 'block';
                                thumb.style.margin = '0 auto';

                                // Remove any constraints that might affect the capture
                                thumb.style.maxWidth = 'none';
                                thumb.style.maxHeight = 'none';
                                thumb.style.minWidth = 'none';
                                thumb.style.minHeight = 'none';

                                // Ensure the parent container doesn't constrain the thumbnail
                                if (thumb.parentElement) {
                                    thumb.parentElement.style.overflow = 'visible';
                                    thumb.parentElement.style.display = 'flex';
                                    thumb.parentElement.style.justifyContent = 'center';
                                    thumb.parentElement.style.alignItems = 'center';
                                }
                            });
                        }
                    });

                    // Restore videos after capture
                    videoPlaceholders.forEach(({ video, placeholder }) => {
                        video.style.display = '';
                        placeholder.remove();
                    });

                    // Convert canvas to blob
                    const blob = await new Promise(resolve => {
                        canvas.toBlob(resolve, 'image/png');
                    });

                    // Add to ZIP
                    const slideName = index === 0 ? 'overview' : `row-${index}-${rowData[index - 1]?.name.toLowerCase().replace(/\s+/g, '-') || 'unknown'}`;
                    zip.file(`buyer-insight-slide-${slideName}.png`, blob);

                    // Update progress
                    showStatus(`Processing slide ${index + 1}/${totalSlides}...`, 'success');
                }

                // Restore original active slide
                slides.forEach(s => s.classList.remove('active'));
                if (currentActiveSlide) {
                    currentActiveSlide.classList.add('active');
                }

                // Generate and download ZIP
                showStatus('Generating ZIP file...', 'success');
                const zipBlob = await zip.generateAsync({ type: 'blob' });

                const link = document.createElement('a');
                link.href = URL.createObjectURL(zipBlob);
                link.download = 'buyer-insight-slides.zip';
                link.click();

                showStatus(`All ${totalSlides} slides downloaded as ZIP!`, 'success');

            } catch (error) {
                console.error('Error creating ZIP:', error);
                showStatus('Error creating ZIP file. Please try again.', 'error');
            }
        }

        async function downloadAsPowerPoint() {
            // Get the button and disable it
            const pptButton = document.getElementById('downloadPPT');
            const originalButtonContent = pptButton.innerHTML;

            // Get the close button and disable it too
            const closeButton = document.getElementById('cancelDownload');
            const originalCloseContent = closeButton.innerHTML;

            // Disable both buttons and show loading state
            pptButton.disabled = true;
            pptButton.style.opacity = '0.6';
            pptButton.style.cursor = 'not-allowed';
            pptButton.innerHTML = '<i class="bi bi-hourglass-split"></i> Generating...';

            closeButton.disabled = true;
            closeButton.style.opacity = '0.6';
            closeButton.style.cursor = 'not-allowed';

            // Check if PptxGenJS is available
            if (typeof PptxGenJS === 'undefined') {
                showStatus('PowerPoint library not available. Downloading as ZIP instead...', 'warning');
                downloadAllSlides();
                // Re-enable buttons
                enablePPTButton(pptButton, originalButtonContent);
                enableCloseButton(closeButton, originalCloseContent);
                return;
            }

            const slides = document.querySelectorAll('.simple-slide');
            const totalSlides = slides.length;

            // Show STAAAR loading modal
            showStaaaarLoadingModal();

            // Start 30-second progress animation
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 100 / 300; // 30 seconds = 300 intervals of 100ms
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                }
                updateProgress(progress);
            }, 100);

            // Wait for 30 seconds before proceeding
            await new Promise(resolve => setTimeout(resolve, 30000));

            try {
                // Create new PowerPoint presentation
                const pptx = new PptxGenJS();

                // Set presentation properties
                pptx.author = 'InsightMap Pro';
                pptx.company = 'InsightMap';
                pptx.title = 'Buyer Insight Map Strategy';
                pptx.subject = 'Strategic Buyer Journey Analysis';

                // Store current active slide
                const currentActiveSlide = document.querySelector('.simple-slide.active');

                // Process all slides and add to PowerPoint
                for (let index = 0; index < slides.length; index++) {
                    const slide = slides[index];

                    // Temporarily make this slide visible for capture
                    slides.forEach(s => s.classList.remove('active'));
                    slide.classList.add('active');

                    // Handle video capture properly
                    const videos = slide.querySelectorAll('video');
                    const videoPlaceholders = [];

                    for (let video of videos) {
                        try {
                            // Try to capture video thumbnail for first slide (overview)
                            if (index === 0 && video.readyState >= 2) {
                                // Create canvas to capture video frame
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');

                                // Get video dimensions
                                const videoWidth = video.videoWidth || 640;
                                const videoHeight = video.videoHeight || 360;
                                const videoAspectRatio = videoWidth / videoHeight;

                                // Set canvas size to match video
                                canvas.width = videoWidth;
                                canvas.height = videoHeight;

                                try {
                                    ctx.drawImage(video, 0, 0, videoWidth, videoHeight);

                                    // Create image element with captured frame
                                    const thumbnail = document.createElement('img');
                                    thumbnail.src = canvas.toDataURL('image/png');

                                    // Calculate optimal thumbnail dimensions based on video aspect ratio
                                    const isVertical = videoAspectRatio < 1; // Vertical if height > width
                                    const maxContainerWidth = 400; // Maximum width for the container
                                    const maxContainerHeight = 380; // Maximum height for the container

                                    let thumbnailWidth, thumbnailHeight;

                                    if (isVertical) {
                                        // For vertical videos, prioritize height and calculate width
                                        thumbnailHeight = Math.min(maxContainerHeight, videoHeight);
                                        thumbnailWidth = thumbnailHeight * videoAspectRatio;
                                    } else {
                                        // For horizontal videos, prioritize width and calculate height
                                        thumbnailWidth = Math.min(maxContainerWidth, videoWidth);
                                        thumbnailHeight = thumbnailWidth / videoAspectRatio;
                                    }

                                    // Apply dimensions that match the video's natural aspect ratio
                                    thumbnail.style.width = thumbnailWidth + 'px';
                                    thumbnail.style.height = thumbnailHeight + 'px';
                                    thumbnail.style.objectFit = 'cover'; // Use cover to fill the exact dimensions
                                    thumbnail.style.objectPosition = 'center';
                                    thumbnail.style.borderRadius = '8px';
                                    thumbnail.style.background = '#000';
                                    thumbnail.style.display = 'block';
                                    thumbnail.style.margin = '0 auto'; // Center the thumbnail
                                    thumbnail.className = 'video-thumbnail-temp';

                                    // Store dimensions and aspect ratio information
                                    thumbnail.setAttribute('data-original-width', videoWidth);
                                    thumbnail.setAttribute('data-original-height', videoHeight);
                                    thumbnail.setAttribute('data-aspect-ratio', videoAspectRatio);
                                    thumbnail.setAttribute('data-is-vertical', isVertical);
                                    thumbnail.setAttribute('data-thumbnail-width', thumbnailWidth);
                                    thumbnail.setAttribute('data-thumbnail-height', thumbnailHeight);

                                    video.style.display = 'none';
                                    video.parentNode.insertBefore(thumbnail, video);
                                    videoPlaceholders.push({ video, placeholder: thumbnail });
                                } catch (e) {
                                    // Fallback to placeholder if thumbnail capture fails
                                    throw e;
                                }
                            } else {
                                throw new Error('Use placeholder');
                            }
                        } catch (e) {
                            // Use placeholder for videos that can't be captured
                            const placeholder = document.createElement('div');
                            placeholder.style.width = video.style.width || '100%';
                            placeholder.style.height = video.style.height || 'auto';
                            placeholder.style.minHeight = '200px';
                            placeholder.style.background = '#000';
                            placeholder.style.borderRadius = video.style.borderRadius || '8px';
                            placeholder.style.display = 'flex';
                            placeholder.style.alignItems = 'center';
                            placeholder.style.justifyContent = 'center';
                            placeholder.style.color = 'white';
                            placeholder.style.fontSize = '14px';
                            placeholder.innerHTML = 'â–¶ Video Content';
                            placeholder.className = 'video-placeholder-temp';

                            video.style.display = 'none';
                            video.parentNode.insertBefore(placeholder, video);
                            videoPlaceholders.push({ video, placeholder });
                        }
                    }

                    // Wait a moment for rendering
                    await new Promise(resolve => setTimeout(resolve, 200));

                    // Get the actual slide dimensions
                    const slideRect = slide.getBoundingClientRect();
                    const actualWidth = slideRect.width;
                    const actualHeight = slideRect.height;

                    const canvas = await html2canvas(slide, {
                        backgroundColor: '#ffffff',
                        scale: 2,
                        useCORS: true,
                        allowTaint: true,
                        foreignObjectRendering: false,
                        ignoreElements: function(element) {
                            // Skip video elements as they cause taint issues
                            return element.tagName === 'VIDEO';
                        },
                        width: actualWidth,
                        height: actualHeight,
                        scrollX: 0,
                        scrollY: 0,
                        onclone: function(clonedDoc) {
                            // Ensure videos and images maintain aspect ratio in clone
                            const images = clonedDoc.querySelectorAll('img');
                            images.forEach(img => {
                                // Preserve original styling
                                img.style.objectFit = 'contain';
                                img.style.maxWidth = '100%';
                                img.style.height = 'auto';
                            });

                            // Handle video thumbnails specifically with aspect ratio preservation
                            const videoThumbnails = clonedDoc.querySelectorAll('.video-thumbnail-temp');
                            videoThumbnails.forEach(thumb => {
                                // Get stored dimension information
                                const thumbnailWidth = thumb.getAttribute('data-thumbnail-width');
                                const thumbnailHeight = thumb.getAttribute('data-thumbnail-height');
                                const isVertical = thumb.getAttribute('data-is-vertical') === 'true';
                                const aspectRatio = thumb.getAttribute('data-aspect-ratio');

                                // Ensure exact dimensions are maintained
                                thumb.style.width = thumbnailWidth + 'px';
                                thumb.style.height = thumbnailHeight + 'px';
                                thumb.style.objectFit = 'cover'; // Use cover to maintain exact aspect ratio
                                thumb.style.objectPosition = 'center';
                                thumb.style.display = 'block';
                                thumb.style.margin = '0 auto';

                                // Remove any constraints that might affect the capture
                                thumb.style.maxWidth = 'none';
                                thumb.style.maxHeight = 'none';
                                thumb.style.minWidth = 'none';
                                thumb.style.minHeight = 'none';

                                // Ensure the parent container doesn't constrain the thumbnail
                                if (thumb.parentElement) {
                                    thumb.parentElement.style.overflow = 'visible';
                                    thumb.parentElement.style.display = 'flex';
                                    thumb.parentElement.style.justifyContent = 'center';
                                    thumb.parentElement.style.alignItems = 'center';
                                }
                            });
                        }
                    });

                    // Restore videos after capture
                    videoPlaceholders.forEach(({ video, placeholder }) => {
                        video.style.display = '';
                        placeholder.remove();
                    });

                    // Add slide to PowerPoint
                    const pptSlide = pptx.addSlide();

                    // Use HTML2Canvas for ALL slides - ensures perfect design match
                    const base64Image = canvas.toDataURL('image/png');
                    pptSlide.addImage({
                        data: base64Image,
                        x: 0,
                        y: 0,
                        w: '100%',
                        h: '100%'
                    });

                    const slideType = index === 0 ? 'Overview' : 'Detail';
                    console.log(`âœ… ${slideType} slide ${index}: HTML2Canvas capture - matches presentation exactly`);

                    // Add slide title as a note for better navigation
                    const slideTitle = index === 0 ? 'Buyer Insight Map Overview' : `${rowData[index - 1]?.name || 'Row ' + index} - Detail View`;
                    pptSlide.addNotes(slideTitle);

                    // Update progress
                    showStatus(`Processing slide ${index + 1}/${totalSlides}...`, 'success');
                }

                // Restore original active slide
                slides.forEach(s => s.classList.remove('active'));
                if (currentActiveSlide) {
                    currentActiveSlide.classList.add('active');
                }

                // Generate and download PowerPoint
                showStatus('Generating PowerPoint file...', 'success');
                await pptx.writeFile({ fileName: 'buyer-insight-strategy.pptx' });

                showStatus(`PowerPoint with ${totalSlides} slides downloaded successfully!`, 'success');

            } catch (error) {
                console.error('Error creating PowerPoint:', error);
                showStatus('Error creating PowerPoint file. Please try again.', 'error');
            } finally {
                // Hide the STAAAR loading modal
                hideStaaaarLoadingModal();

                // Re-enable both buttons
                enablePPTButton(pptButton, originalButtonContent);
                enableCloseButton(closeButton, originalCloseContent);
            }
        }

        function showStaaaarLoadingModal() {
            document.getElementById('staaaarLoadingModal').style.display = 'flex';
            // Reset progress
            updateProgress(0);
        }

        function hideStaaaarLoadingModal() {
            document.getElementById('staaaarLoadingModal').style.display = 'none';
        }

        function updateProgress(percentage) {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            progressFill.style.width = percentage + '%';
            progressText.textContent = Math.round(percentage) + '%';
        }

        function enablePPTButton(button, originalContent) {
            button.disabled = false;
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
            button.innerHTML = originalContent;
        }

        function enableCloseButton(button, originalContent) {
            button.disabled = false;
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
            button.innerHTML = originalContent;
        }

        function downloadMap(transparent) {
            // Legacy function - now downloads current slide
            downloadCurrentSlide();
        }

        function captureMapAsImage() {
            const table = document.getElementById('insightTable');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = 1920;
            canvas.height = 1080;

            // Fill white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('BUYER INSIGHT MAP', canvas.width / 2, 40);

            // Simple text-based representation
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            let y = 80;

            const rows = table.querySelectorAll('tr');
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                const categoryText = cells[0].textContent.replace(/\n/g, ' ');
                const hasImage = cells[1].querySelector('.captured-image') ? 'âœ“' : 'â—‹';

                ctx.fillText(`${categoryText} - Image: ${hasImage}`, 20, y);
                y += 120;
            });

            // Download
            const link = document.createElement('a');
            link.download = 'buyer-insight-map.png';
            link.href = canvas.toDataURL();
            link.click();

            showStatus('Map downloaded!', 'success');
        }

        function showStatus(message, type = 'success') {
            const toastContainer = document.getElementById('toastContainer');

            // Create toast element
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            toast.innerHTML = `
                <div class="toast-message">${message}</div>
                <button class="toast-close" onclick="removeToast(this.parentElement)">&times;</button>
            `;

            // Add to container
            toastContainer.appendChild(toast);

            // Trigger show animation
            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            // Auto remove after 5 seconds
            setTimeout(() => {
                removeToast(toast);
            }, 5000);
        }

        function removeToast(toast) {
            if (toast && toast.parentElement) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.parentElement.removeChild(toast);
                    }
                }, 300);
            }
        }

        function updateConnectionVisuals(rowIndex, textColumnIndex) {
            // Clear previous connections for this row
            const targetRow = document.querySelector(`tr[data-row="${rowIndex}"]`);

            // Remove old connections and arrows
            targetRow.querySelectorAll('.connected-pair').forEach(el => {
                el.classList.remove('connected-pair');
            });

            // Remove existing arrows for this row
            document.querySelectorAll(`.connection-arrow[data-row="${rowIndex}"]`).forEach(arrow => {
                arrow.remove();
            });

            // Add connection to image holder and target text cell
            const imagePlaceholder = targetRow.querySelector('.image-placeholder');
            const textCells = targetRow.querySelectorAll('.text-cell');

            if (imagePlaceholder && textCells[textColumnIndex]) {
                imagePlaceholder.classList.add('connected-pair');
                textCells[textColumnIndex].classList.add('connected-pair');

                // Create and position the arrow
                createConnectionArrow(imagePlaceholder, textCells[textColumnIndex], rowIndex);

                //console.log(`Visual connection updated: row ${rowIndex}, text column ${textColumnIndex}`);
            } else {
                console.warn(`Failed to update visual connection: row ${rowIndex}, text column ${textColumnIndex}, available text cells: ${textCells.length}`);
            }
        }

        function createConnectionArrow(sourceElement, targetElement, rowIndex) {
            const sourceRect = sourceElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            const table = document.getElementById('insightTable');
            const tableRect = table.getBoundingClientRect();

            // Calculate positions relative to the table
            const startX = sourceRect.right - tableRect.left;
            const startY = (sourceRect.top + sourceRect.height / 2) - tableRect.top;
            const endX = targetRect.left - tableRect.left;
            const endY = (targetRect.top + targetRect.height / 2) - tableRect.top;

            // Create arrow element
            const arrow = document.createElement('div');
            arrow.className = 'connection-arrow';
            arrow.dataset.row = rowIndex;

            // Calculate arrow dimensions and position
            const length = endX - startX - 4; // Small gap from elements
            const width = 3;

            arrow.style.left = (startX + 2) + 'px';
            arrow.style.top = startY + 'px';
            arrow.style.width = length + 'px';
            arrow.style.height = width + 'px';

            // Add arrow to table (positioned relative to table)
            table.appendChild(arrow);

            // Add a subtle animation
            arrow.style.opacity = '0';
            arrow.style.transform = 'translateY(-50%) scaleX(0)';
            arrow.style.transformOrigin = 'left center';
            arrow.style.transition = 'all 0.3s ease';

            // Trigger animation
            setTimeout(() => {
                arrow.style.opacity = '1';
                arrow.style.transform = 'translateY(-50%) scaleX(1)';
            }, 50);
        }


        function getValidDropTarget(e, originalRow) {
            const allCells = Array.from(originalRow.querySelectorAll('td:not(.category-cell)'));
            const textCells = allCells.filter(cell => cell.classList.contains('text-cell'));

            // Don't allow dropping on the last text cell (preserve the progression concept)
            const validDropCells = textCells.slice(0, -1);

            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            let targetCell = elementBelow ? elementBelow.closest('td') : null;

            // Check if it's a valid drop target
            if (targetCell && validDropCells.includes(targetCell)) {
                return targetCell;
            }

            // If no direct hit, find closest valid cell
            const mouseX = e.clientX;
            let closestCell = null;
            let minDistance = Infinity;

            validDropCells.forEach(cell => {
                const rect = cell.getBoundingClientRect();
                const cellCenterX = rect.left + rect.width / 2;
                const distance = Math.abs(mouseX - cellCenterX);

                if (distance < minDistance && distance < 100) {
                    minDistance = distance;
                    closestCell = cell;
                }
            });

            return closestCell;
        }

        // Dynamic row buttons management
        function populateRowButtons() {
            const rowSelector = document.getElementById('dynamicRowSelector');
            if (!rowSelector) return;

            // Clear existing buttons
            rowSelector.innerHTML = '';

            // Get all rows from the table
            const tableRows = document.querySelectorAll('tr[data-row]');
            console.log(`ðŸ”§ Populating ${tableRows.length} row buttons for Step 2`);

            tableRows.forEach((row, index) => {
                const categoryCell = row.querySelector('.category-cell');
                let categoryText = '';

                // Extract category text
                const categoryTextElement = categoryCell.querySelector('.category-text');
                if (categoryTextElement) {
                    categoryText = categoryTextElement.textContent.trim();
                } else {
                    categoryText = categoryCell.textContent.trim();
                }

                // Fallback to generic name if no text found
                if (!categoryText) {
                    categoryText = `Row ${index + 1}`;
                } else {
                    // Simplify category text for button (take first word or two)
                    const words = categoryText.split(' ');
                    if (words.length > 2) {
                        categoryText = words.slice(0, 2).join(' ');
                    }
                }

                // Create button
                const button = document.createElement('button');
                button.className = 'row-btn';
                button.setAttribute('data-row', index);
                button.textContent = categoryText;

                rowSelector.appendChild(button);
                console.log(`âœ… Created row button ${index}: "${categoryText}"`);
            });

            // Re-attach event listeners to new buttons
            attachRowButtonListeners();
        }

        function attachRowButtonListeners() {
            const rowBtns = document.querySelectorAll('.row-btn');
            rowBtns.forEach(btn => {
                btn.addEventListener('click', function () {
                    // Check if video is loaded
                    const videoPlayer = document.getElementById('videoPlayer');
                    if (videoPlayer.readyState < 2) {
                        showStatus('Please load a video first!', 'error');
                        return;
                    }

                    // Remove previous selections
                    rowBtns.forEach(b => b.classList.remove('selected'));
                    document.querySelectorAll('tr').forEach(tr => tr.classList.remove('row-highlight'));

                    // Select current row
                    this.classList.add('selected');
                    selectedRow = parseInt(this.dataset.row);

                    // Highlight the row in table
                    const tableRow = document.querySelector(`tr[data-row="${selectedRow}"]`);
                    if (tableRow) {
                        tableRow.classList.add('row-highlight');
                    }

                    // Automatically capture frame
                    captureFrame();
                });
            });
        }

        // Color customization
        let selectedColorRow = null;

        // Helper function to determine if a color is dark (needs white text) or light (needs black text)
        function isColorDark(hexColor) {
            // Convert hex to RGB
            const r = parseInt(hexColor.substr(1, 2), 16);
            const g = parseInt(hexColor.substr(3, 2), 16);
            const b = parseInt(hexColor.substr(5, 2), 16);

            // Calculate luminance
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

            // Return true if dark (luminance < 0.5)
            return luminance < 0.5;
        }

        function populateCategoryButtons() {
            const categoryButtonsContainer = document.getElementById('dynamicCategoryButtons');
            if (!categoryButtonsContainer) {
                console.error('âŒ dynamicCategoryButtons container not found');
                return;
            }

            // Clear existing buttons
            categoryButtonsContainer.innerHTML = '';

            // Get all rows from the table
            const tableRows = document.querySelectorAll('tr[data-row]');
            console.log(`ðŸ”§ Found ${tableRows.length} table rows for category buttons`);

            if (tableRows.length === 0) {
                console.warn('âš ï¸ No table rows found with data-row attribute. Modal may be opening before table is generated.');
                // Show a message in the container
                categoryButtonsContainer.innerHTML = '<p style="text-align: center; color: #64748b; font-style: italic; padding: 20px;">No table data available. Please generate a table first.</p>';
                return;
            }

            // Default colors for rows
            const defaultColors = [
                '#475569', '#0ea5e9', '#8b5cf6', '#06b6d4',
                '#10b981', '#f59e0b', '#ef4444', '#6366f1'
            ];

            tableRows.forEach((row, index) => {
                const categoryCell = row.querySelector('.category-cell');
                if (!categoryCell) return;

                // Extract category text (handle both text and HTML content)
                let categoryText = '';
                const categoryTextElement = categoryCell.querySelector('.category-text');
                if (categoryTextElement) {
                    categoryText = categoryTextElement.textContent.trim();
                } else {
                    categoryText = categoryCell.textContent.trim();
                }

                // Fallback if no text found
                if (!categoryText) {
                    categoryText = `Category ${index + 1}`;
                }

                // Get current background color or use default
                const computedStyle = window.getComputedStyle(categoryCell);
                const currentBgColor = computedStyle.backgroundColor;

                // Use current color or default
                let buttonColor = defaultColors[index] || '#64748b';

                // If category cell has a custom background color, use that
                if (currentBgColor && currentBgColor !== 'rgba(0, 0, 0, 0)' && currentBgColor !== 'transparent') {
                    buttonColor = currentBgColor;
                }

                // Create button
                const button = document.createElement('button');
                button.className = 'modern-row-btn';
                button.setAttribute('data-row', index);
                button.style.background = buttonColor;
                button.innerHTML = `<span class="row-name">${categoryText}</span>`;

                categoryButtonsContainer.appendChild(button);
                console.log(`âœ… Created button for row ${index}: "${categoryText}" with color ${buttonColor}`);
            });

            // Adjust grid layout based on number of rows
            const numRows = tableRows.length;
            if (numRows <= 2) {
                categoryButtonsContainer.style.gridTemplateColumns = '1fr';
            } else if (numRows <= 4) {
                categoryButtonsContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
            } else {
                categoryButtonsContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
            }

            // Re-attach event listeners to new buttons
            attachCategoryButtonListeners();
        }

        function initializeContentColors() {
            console.log('ðŸŽ¨ Initializing content colors...');
            // Get current colors from a text cell (if any exist)
            const firstTextCell = document.querySelector('.text-cell');
            if (firstTextCell) {
                const computedStyle = window.getComputedStyle(firstTextCell);

                // Get background color
                const bgColor = computedStyle.backgroundColor;
                if (bgColor && bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
                    // Convert RGB to hex
                    const rgbMatch = bgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (rgbMatch) {
                        const hex = '#' + [rgbMatch[1], rgbMatch[2], rgbMatch[3]]
                            .map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
                        document.getElementById('contentBgColorPicker').value = hex;
                        document.getElementById('contentBgPreview').style.background = hex;
                        document.getElementById('contentTextPreview').style.background = hex;
                    }
                }

                // Get text color
                const textColor = computedStyle.color;
                if (textColor) {
                    const rgbMatch = textColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (rgbMatch) {
                        const hex = '#' + [rgbMatch[1], rgbMatch[2], rgbMatch[3]]
                            .map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
                        document.getElementById('contentTextColorPicker').value = hex;
                        document.getElementById('contentTextPreview').style.color = hex;
                    }
                }
            }

            // Get current icon color
            const firstIcon = document.querySelector('.text-cell i');
            if (firstIcon) {
                const iconStyle = window.getComputedStyle(firstIcon);
                const iconColor = iconStyle.color;
                if (iconColor) {
                    const rgbMatch = iconColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (rgbMatch) {
                        const hex = '#' + [rgbMatch[1], rgbMatch[2], rgbMatch[3]]
                            .map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
                        document.getElementById('contentIconColorPicker').value = hex;
                        document.getElementById('iconPreviewIcon').style.color = hex;
                    }
                }
            }

            console.log('ðŸŽ¨ Content colors initialized from current table state');
        }

        function attachCategoryButtonListeners() {
            const buttons = document.querySelectorAll('.modern-row-btn');
            console.log(`ðŸ”§ Attaching listeners to ${buttons.length} category buttons`);

            buttons.forEach(btn => {
                btn.addEventListener('click', function () {
                    console.log('ðŸ”§ Category button clicked:', this.textContent.trim());
                    // Remove previous selection
                    document.querySelectorAll('.modern-row-btn').forEach(b => b.classList.remove('selected'));

                    // Select current button
                    this.classList.add('selected');
                    selectedColorRow = parseInt(this.dataset.row);

                    // Show category color section
                    const categorySection = document.getElementById('categoryColorSection');
                    if (categorySection) {
                        categorySection.style.display = 'block';
                        console.log('âœ… Category color section shown');
                    } else {
                        console.error('âŒ categoryColorSection element not found');
                    }

                    // Get the actual row from the table to get current text color
                    const actualRow = document.querySelector(`tr[data-row="${selectedColorRow}"]`);
                    const categoryCell = actualRow?.querySelector('.category-cell');

                    // Update label and preview
                    const rowName = this.querySelector('.row-name').textContent;
                    const currentBgColor = window.getComputedStyle(this).backgroundColor;

                    document.getElementById('selectedRowLabel').textContent = rowName;
                    // Update both previews with current background color
                    document.getElementById('categoryBgPreview').style.background = currentBgColor;
                    document.getElementById('categoryTextPreview').style.background = currentBgColor;

                    // Convert RGB to hex for color picker
                    const rgbMatch = currentBgColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                    if (rgbMatch) {
                        const hex = '#' + [rgbMatch[1], rgbMatch[2], rgbMatch[3]]
                            .map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
                        document.getElementById('selectedRowColorPicker').value = hex;

                        // Get current text color from actual category cell
                        let currentTextColor = '#ffffff'; // fallback
                        if (categoryCell) {
                            const cellStyle = window.getComputedStyle(categoryCell);
                            const cellTextColor = cellStyle.color;
                            if (cellTextColor) {
                                const textRgbMatch = cellTextColor.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                                if (textRgbMatch) {
                                    currentTextColor = '#' + [textRgbMatch[1], textRgbMatch[2], textRgbMatch[3]]
                                        .map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
                                }
                            }
                        } else {
                            // Fallback to auto contrast
                            currentTextColor = isColorDark(hex) ? '#ffffff' : '#000000';
                        }

                        document.getElementById('categoryTextColorPicker').value = currentTextColor;
                        document.getElementById('categoryTextPreview').style.color = currentTextColor;

                        // Update preview text color in the selected button
                        const rowName = this.querySelector('.row-name');
                        if (rowName) {
                            rowName.style.color = currentTextColor;
                        }
                    }
                });
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Color modal button
            const colorCustomizeBtn = document.getElementById('colorCustomizeBtn');
            if (colorCustomizeBtn) {
                colorCustomizeBtn.addEventListener('click', function () {
                    const colorModal = document.getElementById('colorModal');
                    if (colorModal) {
                        try {
                            console.log('ðŸ”§ Opening color modal...');

                            // Populate category buttons from current table data
                            console.log('ðŸ”§ Populating category buttons...');
                            populateCategoryButtons();

                            // Initialize content colors from current table state
                            console.log('ðŸ”§ Initializing content colors...');
                            initializeContentColors();

                            console.log('ðŸ”§ Adding show class...');
                            colorModal.classList.add('show');

                            // Test if all category color elements exist
                            const testCategorySection = document.getElementById('categoryColorSection');
                            const testSelectedRowLabel = document.getElementById('selectedRowLabel');
                            const testSelectedRowColorPicker = document.getElementById('selectedRowColorPicker');
                            const testCategoryTextColorPicker = document.getElementById('categoryTextColorPicker');
                            const testCategoryBgPreview = document.getElementById('categoryBgPreview');
                            const testCategoryTextPreview = document.getElementById('categoryTextPreview');

                            console.log('ðŸ”§ Category elements check:');
                            console.log('- categoryColorSection:', !!testCategorySection);
                            console.log('- selectedRowLabel:', !!testSelectedRowLabel);
                            console.log('- selectedRowColorPicker:', !!testSelectedRowColorPicker);
                            console.log('- categoryTextColorPicker:', !!testCategoryTextColorPicker);
                            console.log('- categoryBgPreview:', !!testCategoryBgPreview);
                            console.log('- categoryTextPreview:', !!testCategoryTextPreview);

                            console.log('âœ… Color modal opened successfully');
                        } catch (error) {
                            console.error('âŒ Error opening color modal:', error);
                            // Still try to show modal even if initialization fails
                            colorModal.classList.add('show');
                        }
                    }
                });
            }

            // Category buttons are now dynamically created, so no static listeners needed

            // Category background color picker change
            const selectedRowColorPicker = document.getElementById('selectedRowColorPicker');
            if (selectedRowColorPicker) {
                selectedRowColorPicker.addEventListener('input', function () {
                const color = this.value;

                // Update both preview boxes
                const categoryBgPreview = document.getElementById('categoryBgPreview');
                const categoryTextPreview = document.getElementById('categoryTextPreview');

                if (categoryBgPreview) {
                    categoryBgPreview.style.background = color;
                    console.log(`âœ… Updated categoryBgPreview to ${color}`);
                } else {
                    console.error('âŒ categoryBgPreview not found');
                }

                if (categoryTextPreview) {
                    categoryTextPreview.style.background = color;
                    console.log(`âœ… Updated categoryTextPreview background to ${color}`);
                } else {
                    console.error('âŒ categoryTextPreview not found');
                }

                // Update the selected button preview
                const selectedBtn = document.querySelector('.modern-row-btn.selected');
                if (selectedBtn) {
                    selectedBtn.style.background = color;
                }

                // Set default text color based on new background
                const autoTextColor = isColorDark(color) ? '#ffffff' : '#000000';
                document.getElementById('categoryTextColorPicker').value = autoTextColor;
                document.getElementById('categoryTextPreview').style.color = autoTextColor;

                // Update button text color
                const rowName = selectedBtn?.querySelector('.row-name');
                if (rowName) {
                    rowName.style.color = autoTextColor;
                }
                });
            } else {
                console.error('âŒ selectedRowColorPicker not found when attaching event listener');
            }

            // Category text color picker change
            const categoryTextColorPicker = document.getElementById('categoryTextColorPicker');
            if (categoryTextColorPicker) {
                categoryTextColorPicker.addEventListener('input', function () {
                const color = this.value;

                // Update preview box
                const categoryTextPreview = document.getElementById('categoryTextPreview');
                if (categoryTextPreview) {
                    categoryTextPreview.style.color = color;
                    console.log(`âœ… Updated categoryTextPreview text color to ${color}`);
                } else {
                    console.error('âŒ categoryTextPreview not found for text color update');
                }

                // Update preview in the selected button
                const selectedBtn = document.querySelector('.modern-row-btn.selected');
                if (selectedBtn) {
                    const rowName = selectedBtn.querySelector('.row-name');
                    if (rowName) {
                        rowName.style.color = color;
                    }
                }

                console.log(`ðŸŽ¨ Category text color changed to: ${color}`);
                });
            } else {
                console.error('âŒ categoryTextColorPicker not found when attaching event listener');
            }

            // Auto contrast button
            const autoContrastBtn = document.getElementById('autoContrastBtn');
            if (autoContrastBtn) {
                autoContrastBtn.addEventListener('click', function () {
                const bgColor = document.getElementById('selectedRowColorPicker').value;
                const autoTextColor = isColorDark(bgColor) ? '#ffffff' : '#000000';
                document.getElementById('categoryTextColorPicker').value = autoTextColor;

                // Update preview box
                document.getElementById('categoryTextPreview').style.color = autoTextColor;

                // Update preview in the selected button
                const selectedBtn = document.querySelector('.modern-row-btn.selected');
                if (selectedBtn) {
                    const rowName = selectedBtn.querySelector('.row-name');
                    if (rowName) {
                        rowName.style.color = autoTextColor;
                    }
                }

                console.log(`ðŸŽ¯ Auto contrast applied: ${autoTextColor} for background ${bgColor}`);
                });
            } else {
                console.error('âŒ autoContrastBtn not found when attaching event listener');
            }

            // Content background color picker
            document.getElementById('contentBgColorPicker').addEventListener('input', function () {
                const color = this.value;
                document.getElementById('contentBgPreview').style.background = color;
                document.getElementById('contentTextPreview').style.background = color;

                // Set default text color based on new background
                const autoTextColor = isColorDark(color) ? '#ffffff' : '#000000';
                document.getElementById('contentTextColorPicker').value = autoTextColor;
                document.getElementById('contentTextPreview').style.color = autoTextColor;
            });

            // Content text color picker
            document.getElementById('contentTextColorPicker').addEventListener('input', function () {
                const color = this.value;
                document.getElementById('contentTextPreview').style.color = color;
            });

            // Content auto contrast button
            document.getElementById('contentAutoContrastBtn').addEventListener('click', function () {
                const bgColor = document.getElementById('contentBgColorPicker').value;
                const autoTextColor = isColorDark(bgColor) ? '#ffffff' : '#000000';
                document.getElementById('contentTextColorPicker').value = autoTextColor;
                document.getElementById('contentTextPreview').style.color = autoTextColor;
                console.log(`ðŸŽ¯ Content auto contrast applied: ${autoTextColor} for background ${bgColor}`);
            });

            // Content icon color picker
            document.getElementById('contentIconColorPicker').addEventListener('input', function () {
                const color = this.value;
                document.getElementById('iconPreviewIcon').style.color = color;
            });

            // Apply color to all categories button
            const applyToAllCategoriesBtn = document.getElementById('applyToAllCategories');
            if (applyToAllCategoriesBtn) {
                applyToAllCategoriesBtn.addEventListener('click', function () {
                const categoryBgColor = document.getElementById('selectedRowColorPicker').value;
                const categoryTextColor = document.getElementById('categoryTextColorPicker').value;

                console.log(`ðŸŽ¨ Applying colors to all categories: bg=${categoryBgColor}, text=${categoryTextColor}`);

                // Apply to all category cells
                const allCategoryCells = document.querySelectorAll('.category-cell');
                console.log(`ðŸŽ¨ Applying category colors to all ${allCategoryCells.length} category cells`);
                console.log(`ðŸŽ¨ Colors: bg=${categoryBgColor}, text=${categoryTextColor}`);

                allCategoryCells.forEach((categoryCell, index) => {
                    // Apply background color
                    categoryCell.style.setProperty('background-color', categoryBgColor, 'important');
                    categoryCell.style.setProperty('background', categoryBgColor, 'important');
                    categoryCell.style.setProperty('color', categoryTextColor, 'important');

                    // Update any child text elements within the category cell
                    const categoryTextElements = categoryCell.querySelectorAll('div, span, .category-text');
                    categoryTextElements.forEach(textEl => {
                        textEl.style.setProperty('color', categoryTextColor, 'important');
                    });

                    console.log(`âœ… Applied to category cell ${index}: bg=${categoryBgColor}, text=${categoryTextColor}`);
                });

                // Update all category buttons in the modal to reflect the change
                document.querySelectorAll('.modern-row-btn').forEach(btn => {
                    btn.style.background = categoryBgColor;

                    // Update text color in the button preview
                    const rowName = btn.querySelector('.row-name');
                    if (rowName) {
                        rowName.style.color = categoryTextColor;
                    }
                });

                showStatus(`Applied colors to all categories!`, 'success');
                });
            } else {
                console.error('âŒ applyToAllCategories button not found when attaching event listener');
            }

            // Apply color changes
            document.getElementById('applyColorChanges').addEventListener('click', function () {
                // Apply category color to selected row
                if (selectedColorRow !== null) {
                    const categoryBgColor = document.getElementById('selectedRowColorPicker').value;
                    const categoryTextColor = document.getElementById('categoryTextColorPicker').value;
                    const targetRow = document.querySelector(`tr[data-row="${selectedColorRow}"]`);

                    if (targetRow) {
                        const categoryCell = targetRow.querySelector('.category-cell');
                        if (categoryCell) {
                            // Apply background color with !important to override any existing styles
                            categoryCell.style.setProperty('background-color', categoryBgColor, 'important');
                            categoryCell.style.setProperty('background', categoryBgColor, 'important');

                            // Apply custom text color
                            categoryCell.style.setProperty('color', categoryTextColor, 'important');

                            // Update any child text elements within the category cell
                            const categoryTextElements = categoryCell.querySelectorAll('div, span, .category-text');
                            categoryTextElements.forEach(textEl => {
                                textEl.style.setProperty('color', categoryTextColor, 'important');
                            });

                            // Handle specific category cell structures
                            const categoryText = categoryCell.querySelector('.category-text');
                            if (categoryText) {
                                categoryText.style.setProperty('color', categoryTextColor, 'important');
                            }

                            console.log(`âœ… Applied category colors to row ${selectedColorRow}: bg=${categoryBgColor}, text=${categoryTextColor}`);
                        } else {
                            console.error(`âŒ Category cell not found in row ${selectedColorRow}`);
                        }
                    } else {
                        console.error(`âŒ Target row ${selectedColorRow} not found in DOM`);
                    }
                }

                // Apply content colors to all text cells
                const contentBgColor = document.getElementById('contentBgColorPicker').value;
                const contentTextColor = document.getElementById('contentTextColorPicker').value;
                const contentIconColor = document.getElementById('contentIconColorPicker').value;

                const textCells = document.querySelectorAll('.text-cell');
                console.log(`ðŸŽ¨ Applying content colors to ${textCells.length} text cells`);
                console.log(`ðŸŽ¨ Colors: bg=${contentBgColor}, text=${contentTextColor}, icons=${contentIconColor}`);

                textCells.forEach((cell, index) => {
                    // Apply with !important to override any existing styles
                    cell.style.setProperty('background-color', contentBgColor, 'important');
                    cell.style.setProperty('background', contentBgColor, 'important');
                    cell.style.setProperty('color', contentTextColor, 'important');

                    // Update all child text elements
                    const textElements = cell.querySelectorAll('div, span, p');
                    textElements.forEach(textEl => {
                        textEl.style.setProperty('color', contentTextColor, 'important');
                    });

                    // Update icon colors with user-selected color
                    const icons = cell.querySelectorAll('i, .bi');
                    icons.forEach(icon => {
                        icon.style.setProperty('color', contentIconColor, 'important');
                    });

                    // Handle specific cell structures (like icon + text combos)
                    const cellContent = cell.querySelector('[style*="flex-direction: column"]');
                    if (cellContent) {
                        cellContent.style.setProperty('background-color', contentBgColor, 'important');

                        // Update text within structured cells
                        const textDivs = cellContent.querySelectorAll('div:not(.bi):not([class*="bi-"])');
                        textDivs.forEach(textDiv => {
                            if (textDiv.textContent.trim() && !textDiv.querySelector('i')) {
                                textDiv.style.setProperty('color', contentTextColor, 'important');
                            }
                        });

                        // Update icons within structured cells
                        const structuredIcons = cellContent.querySelectorAll('i, .bi');
                        structuredIcons.forEach(icon => {
                            icon.style.setProperty('color', contentIconColor, 'important');
                        });
                    }

                    console.log(`ðŸŽ¨ Updated cell ${index}: bg=${contentBgColor}, text=${contentTextColor}, icons=${contentIconColor}`);
                });

                console.log(`âœ… Applied content colors: bg=${contentBgColor}, text=${contentTextColor}`);

                // Verify changes were applied by checking a few cells
                setTimeout(() => {
                    const sampleCells = document.querySelectorAll('.text-cell');
                    console.log(`ðŸ” Verification: Checking ${Math.min(3, sampleCells.length)} sample cells:`);

                    for (let i = 0; i < Math.min(3, sampleCells.length); i++) {
                        const cell = sampleCells[i];
                        const computedBg = window.getComputedStyle(cell).backgroundColor;
                        const computedColor = window.getComputedStyle(cell).color;
                        console.log(`   Cell ${i}: bg=${computedBg}, text=${computedColor}`);
                    }
                }, 100);

                // Force a repaint to ensure all changes are visible
                document.body.style.display = 'none';
                document.body.offsetHeight; // Trigger reflow
                document.body.style.display = '';

                document.getElementById('colorModal').classList.remove('show');
                showStatus('Brand colors applied successfully!', 'success');
            });

            // Cancel color changes
            document.getElementById('cancelColorChanges').addEventListener('click', function () {
                document.getElementById('colorModal').classList.remove('show');
            });

            // Close modal button
            document.getElementById('closeColorModal').addEventListener('click', function () {
                document.getElementById('colorModal').classList.remove('show');
            });

            // Video Modal functionality
            const videoModal = document.getElementById('videoModal');
            const openVideoModalBtn = document.getElementById('openVideoModal');
            const closeVideoModalBtn = document.getElementById('closeVideoModal');
            const modalUploadBtn = document.getElementById('modalUploadBtn');
            const modalVideoInput = document.getElementById('modalVideoInput');
            const videoPlayer = document.getElementById('videoPlayer');

            // Open video modal
            if (openVideoModalBtn) {
                console.log('âœ… Video modal button found, attaching event listener');
                openVideoModalBtn.addEventListener('click', function () {
                    console.log('ðŸ”§ Video modal button clicked');
                    if (videoModal) {
                        console.log('âœ… Video modal found, opening modal');
                        loadServerVideos();
                        videoModal.classList.add('show');
                    } else {
                        console.error('âŒ Video modal element not found');
                    }
                });
            } else {
                console.error('âŒ openVideoModalBtn not found');
            }

            // Close video modal
            if (closeVideoModalBtn) {
                closeVideoModalBtn.addEventListener('click', function () {
                    videoModal.classList.remove('show');
                });
            }

            // Modal upload button
            if (modalUploadBtn) {
                modalUploadBtn.addEventListener('click', function () {
                    modalVideoInput.click();
                });
            }

            // Handle modal video upload
            if (modalVideoInput) {
                modalVideoInput.addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (file) {
                        const url = URL.createObjectURL(file);
                        videoPlayer.src = url;
                        videoModal.classList.remove('show');
                        showStatus(`Video "${file.name}" loaded successfully!`, 'success');
                    }
                });
            }

            // Load videos function (client-side for GitHub Pages)
            function loadServerVideos() {
                console.log('ðŸ”§ loadServerVideos called');
                const serverVideosList = document.getElementById('serverVideosList');
                const videosLoading = document.getElementById('videosLoading');

                if (!serverVideosList) {
                    console.error('âŒ serverVideosList element not found');
                    return;
                }

                // Show loading state - recreate if it doesn't exist
                if (videosLoading) {
                    videosLoading.style.display = 'block';
                } else {
                    // Recreate loading element if it was removed
                    serverVideosList.innerHTML = `
                        <div id="videosLoading" style="text-align: center; padding: 40px; color: #64748b;">
                            <i class="bi bi-hourglass-split" style="font-size: 24px; margin-bottom: 8px; display: block;"></i>
                            Loading videos...
                        </div>
                    `;
                }
                console.log('ðŸ”§ Loading videos from videos directory');

                // Parse video metadata from filename: brandname_campaignname_year_industry_country_target.mp4
                function parseVideoMetadata(filename) {
                    const nameWithoutExt = filename.replace(/\.[^/.]+$/, ''); // Remove extension
                    const parts = nameWithoutExt.split('_');

                    if (parts.length >= 6) {
                        return {
                            brand: parts[0] || 'Unknown',
                            campaign: parts[1] || 'Unknown',
                            year: parts[2] || new Date().getFullYear().toString(),
                            industry: parts[3] || 'General',
                            country: parts[4] || 'Global',
                            target: parts[5] || 'General',
                            filename: filename
                        };
                    } else {
                        // Fallback for non-standard filenames
                        return {
                            brand: 'Unknown',
                            campaign: nameWithoutExt,
                            year: new Date().getFullYear().toString(),
                            industry: 'General',
                            country: 'Global',
                            target: 'General',
                            filename: filename
                        };
                    }
                }

                // Get video duration using HTML5 video element
                function getVideoDuration(videoSrc) {
                    return new Promise((resolve) => {
                        const video = document.createElement('video');
                        video.preload = 'metadata';
                        video.onloadedmetadata = () => {
                            const duration = video.duration;
                            const minutes = Math.floor(duration / 60);
                            const seconds = Math.floor(duration % 60);
                            resolve(`${minutes}:${seconds.toString().padStart(2, '0')}`);
                        };
                        video.onerror = () => resolve('--:--');
                        video.src = videoSrc;
                    });
                }

                // Read video file list from video-list.txt
                async function getVideoFileList() {
                    try {
                        const response = await fetch('./video-list.txt');
                        if (!response.ok) {
                            throw new Error('video-list.txt not found');
                        }

                        const text = await response.text();
                        const lines = text.split('\n')
                            .map(line => line.trim())
                            .filter(line => line && !line.startsWith('#'))
                            .filter(line => line.endsWith('.mp4'));

                        console.log(`ðŸ“„ Loaded ${lines.length} videos from video-list.txt`);
                        return lines;
                    } catch (error) {
                        console.error('Could not load video-list.txt:', error);
                        showStatus('Could not load video list. Please check video-list.txt file.', 'error');
                        return []; // Return empty array instead of dummy data
                    }
                }

                // Process video files and get metadata
                setTimeout(async () => {
                    const videos = [];

                    // Get video files from the list
                    const videoFilenames = await getVideoFileList();
                    console.log(`ðŸ” Processing ${videoFilenames.length} video files`);

                    // Process each video file
                    for (const filename of videoFilenames) {
                        try {
                            const videoPath = `./videos/${filename}`;
                            const metadata = parseVideoMetadata(filename);
                            const duration = await getVideoDuration(videoPath);

                            videos.push({
                                ...metadata,
                                duration: duration,
                                path: videoPath
                            });

                            console.log(`âœ… Processed: ${metadata.brand} - ${metadata.campaign} (${duration})`);
                        } catch (error) {
                            console.warn(`âš ï¸ Could not process ${filename}:`, error);
                        }
                    }

                    console.log(`âœ… Successfully loaded ${videos.length} videos`);

                    // Hide loading state safely
                    const loadingElement = document.getElementById('videosLoading');
                    if (loadingElement) {
                        loadingElement.style.display = 'none';
                    }

                    if (videos.length === 0) {
                        console.log('âš ï¸ No videos found');
                        serverVideosList.innerHTML = '<div style="text-align: center; padding: 40px; color: #64748b;"><i class="bi bi-camera-video" style="font-size: 24px; margin-bottom: 8px; display: block;"></i>No videos available.<br><br><small style="color: #94a3b8;">Add video files to ./videos/ folder with format:<br>brandname_campaignname_industry_country_target.mp4</small></div>';
                        return;
                    }

                    // Clear loading and populate videos
                    console.log('ðŸ”§ Populating video list');
                    serverVideosList.innerHTML = '';

                    videos.forEach((video, index) => {
                            console.log(`ðŸ”§ Creating video item ${index + 1}: ${video.brand} - ${video.campaign}`);
                            const videoItem = document.createElement('div');
                            videoItem.style.cssText = `
                                display: flex;
                                align-items: center;
                                gap: 16px;
                                padding: 16px;
                                background: white;
                                border: 1px solid #e2e8f0;
                                border-radius: 12px;
                                cursor: pointer;
                                transition: all 0.2s ease;
                                margin-bottom: 12px;
                            `;

                            // Create video element for thumbnail
                            const videoElement = document.createElement('video');
                            videoElement.style.cssText = `
                                width: 80px;
                                height: 60px;
                                border-radius: 8px;
                                object-fit: cover;
                                background: #f1f5f9;
                            `;
                            videoElement.muted = true;
                            videoElement.preload = 'metadata';
                            videoElement.src = `${video.path}#t=1`; // Get frame at 1 second

                            // Fallback thumbnail container
                            const thumbnailContainer = document.createElement('div');
                            thumbnailContainer.style.cssText = `
                                width: 80px;
                                height: 60px;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                border-radius: 8px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                position: relative;
                                overflow: hidden;
                            `;

                            // Play icon overlay
                            const playIcon = document.createElement('div');
                            playIcon.innerHTML = '<i class="bi bi-play-fill" style="color: white; font-size: 24px;"></i>';
                            playIcon.style.cssText = `
                                position: absolute;
                                top: 50%;
                                left: 50%;
                                transform: translate(-50%, -50%);
                                background: rgba(0, 0, 0, 0.6);
                                border-radius: 50%;
                                width: 32px;
                                height: 32px;
                                display: flex;
                                align-items: center;
                                justify-content: center;
                                z-index: 2;
                            `;

                            // Add video thumbnail
                            thumbnailContainer.appendChild(videoElement);
                            thumbnailContainer.appendChild(playIcon);

                            // Video info section
                            const infoSection = document.createElement('div');
                            infoSection.style.cssText = 'flex: 1;';
                            infoSection.innerHTML = `
                                <div style="font-weight: 600; color: #1e293b; margin-bottom: 6px; font-size: 14px; display: flex; align-items: center; gap: 8px;">
                                    <i class="bi bi-play-circle" style="color: #3b82f6;"></i>
                                    ${video.brand} - ${video.campaign}
                                    <span style="background: #e5e7eb; padding: 1px 6px; border-radius: 6px; font-size: 10px; color: #6b7280; font-weight: 500;">${video.year}</span>
                                </div>
                                <div style="font-size: 11px; color: #64748b; margin-bottom: 8px; display: flex; gap: 6px; flex-wrap: wrap;">
                                    <span style="background: #f1f5f9; padding: 2px 6px; border-radius: 8px; display: flex; align-items: center; gap: 3px; font-weight: 500;">
                                        <i class="bi bi-building" style="font-size: 9px; color: #3b82f6;"></i>${video.industry}
                                    </span>
                                    <span style="background: #fef3c7; padding: 2px 6px; border-radius: 8px; display: flex; align-items: center; gap: 3px; font-weight: 500;">
                                        <i class="bi bi-geo-alt" style="font-size: 9px; color: #f59e0b;"></i>${video.country}
                                    </span>
                                    <span style="background: #dbeafe; padding: 2px 6px; border-radius: 8px; display: flex; align-items: center; gap: 3px; font-weight: 500;">
                                        <i class="bi bi-people" style="font-size: 9px; color: #3b82f6;"></i>${video.target}
                                    </span>
                                </div>
                                <div style="font-size: 11px; color: #94a3b8; display: flex; align-items: center; gap: 6px;">
                                    <span style="display: flex; align-items: center; gap: 3px;">
                                        <i class="bi bi-clock" style="font-size: 9px;"></i>${video.duration}
                                    </span>
                                    <span>â€¢</span>
                                    <span>Click anywhere to load video</span>
                                </div>
                            `;

                            // Load button
                            const loadButton = document.createElement('button');
                            loadButton.innerHTML = '<i class="bi bi-play-circle" style="margin-right: 4px;"></i>Load';
                            loadButton.style.cssText = `
                                padding: 8px 16px;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                border: none;
                                border-radius: 6px;
                                font-size: 12px;
                                font-weight: 500;
                                cursor: pointer;
                                transition: all 0.2s ease;
                            `;

                            // Assemble the video item
                            videoItem.appendChild(thumbnailContainer);
                            videoItem.appendChild(infoSection);
                            videoItem.appendChild(loadButton);

                            // Add hover effects
                            videoItem.addEventListener('mouseenter', function () {
                                this.style.borderColor = '#667eea';
                                this.style.boxShadow = '0 8px 25px rgba(102, 126, 234, 0.15)';
                                this.style.transform = 'translateY(-2px)';
                                loadButton.style.background = 'linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%)';
                            });

                            videoItem.addEventListener('mouseleave', function () {
                                this.style.borderColor = '#e2e8f0';
                                this.style.boxShadow = 'none';
                                this.style.transform = 'translateY(0)';
                                loadButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                            });

                            // Add click handler to load video
                            const loadVideoHandler = function () {
                                console.log(`ðŸ”§ Loading video: ${video.brand} - ${video.campaign}`);
                                videoPlayer.src = video.path;
                                videoModal.classList.remove('show');
                                showStatus(`Video "${video.brand} - ${video.campaign}" loaded successfully!`, 'success');
                            };

                            // Add click handlers to both the item and the load button
                            videoItem.addEventListener('click', loadVideoHandler);
                            loadButton.addEventListener('click', function(e) {
                                e.stopPropagation(); // Prevent double-triggering
                                loadVideoHandler();
                            });

                            serverVideosList.appendChild(videoItem);
                        });
                }, 500); // 500ms delay to show loading state
            }

            // Test function to verify modal works
            function testVideoModal() {
                console.log('ðŸ§ª Testing video modal functionality...');
                const videoModal = document.getElementById('videoModal');
                const openVideoModalBtn = document.getElementById('openVideoModal');

                console.log('- videoModal element:', !!videoModal);
                console.log('- openVideoModalBtn element:', !!openVideoModalBtn);

                if (videoModal && openVideoModalBtn) {
                    console.log('âœ… All elements found. Try clicking the "Load Anchor Video File" button.');
                } else {
                    console.error('âŒ Some elements are missing');
                }
            }

            // Call test function after a short delay
            setTimeout(testVideoModal, 1000);

        });


        function toggleWatermarks(enabled) {
            watermarksEnabled = enabled;

            // Toggle video watermark
            const videoContainer = document.querySelector('.video-container');
            if (enabled) {
                videoContainer.classList.add('watermarked');
            } else {
                videoContainer.classList.remove('watermarked');
            }
        }







        // Prevent default drag behavior on images
        document.addEventListener('dragstart', function (e) {
            if (e.target.tagName === 'IMG') {
                e.preventDefault();
            }
        });

        window.addEventListener('resize', function () {
            // Redraw all existing arrows
            Object.keys(imageConnections).forEach(key => {
                const rowIndex = parseInt(key.split('-')[1]);
                const textColumnIndex = imageConnections[key];
                updateConnectionVisuals(rowIndex, textColumnIndex);
            });
        });

        window.addEventListener('load', function () {
            // Bootstrap Icons CSS already loaded statically in head
            setTimeout(() => {
                // addBootstrapIconsToTextCells(); // Disabled - icons now come from JSON
                enableIconCustomization();
                //console.log('Icons automatically loaded');
            }, 500);
        });
    </script>

    <!-- Modern Footer -->
    <footer class="modern-footer">
        <div class="footer-content">
            <div class="footer-left">
                <div class="footer-logo">
                    <span class="logo">STRATEGY STAAAR</span>
                    <span class="logo-tagline">Pro</span>
                </div>
                <p class="footer-description">AI has taken over much of the generic brand strategy and frameworks. Now, freelancers need to shift their focus â€” turning their strategy knowledge and skills into strategy that agencies, advertisers, and achievers repeat-buy. Deliver insights AI canâ€™t replicate, package them in ready-to-use formats, and create strategies that clients pay for month after month</p>
            </div>
            <div class="footer-links">
                <div class="footer-column">
                    <h4>Product</h4>
                    <a href="#">Features</a>
                    <a href="#">Templates</a>
                    <a href="#">Export Options</a>
                    <a href="#">Integrations</a>
                </div>
                <div class="footer-column">
                    <h4>Resources</h4>
                    <a href="#">Documentation</a>
                    <a href="#">Tutorials</a>
                    <a href="#">Best Practices</a>
                    <a href="#">Support</a>
                </div>
                <div class="footer-column">
                    <h4>Company</h4>
                    <a href="#">About</a>
                    <a href="#">Contact</a>
                    <a href="#">Privacy</a>
                    <a href="#">Terms</a>
                </div>
            </div>
        </div>
        <div class="footer-bottom">
            <div class="footer-bottom-content">
                <p>&copy; 2024 InsightMap Pro. All rights reserved.</p>
                <div class="footer-social">
                    <span>Built with â¤ï¸ for marketers</span>
                </div>
            </div>
        </div>
    </footer>

    <script>
        const SUPABASE_URL = "https://yxicubfthxkwqcihrdhe.supabase.co";
        const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl4aWN1YmZ0aHhrd3FjaWhyZGhlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTgyMjg3NDEsImV4cCI6MjA3MzgwNDc0MX0.-w4VQhAIF0kYLHv87JazGLxgX-r4VXCJaPVSmOUher4";

        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        async function checkUser() {
            // Get current session
            const { data: { session }, error } = await supabaseClient.auth.getSession();
            if (error) {
                console.error("Auth error:", error.message);
                window.location.href = 'login.html';
                return;
            }
            const user = session?.user;
            if (user) {
                console.log("âœ… User logged in:", user);
                // User is logged in, show profile and update DB
                console.log("Calling updateUserProfile...");
                updateUserProfile(user);
                console.log("Calling updateUserLogin...");
                await updateUserLogin(user);
            } else {
                console.log("âŒ User not logged in, redirecting to login...");
                window.location.href = 'login.html';
            }
        }

        function updateUserProfile(user) {
            const userProfile = document.getElementById('userProfile');
            const profileName = document.getElementById('profileName');
            const profileEmail = document.getElementById('profileEmail');
            const profileImage = document.getElementById('profileImage');

            // Show profile section
            userProfile.style.display = 'block';

            // Update profile info
            const name = user.user_metadata?.full_name ||
                        user.user_metadata?.name ||
                        user.user_metadata?.given_name + ' ' + user.user_metadata?.family_name ||
                        user.email?.split('@')[0] || 'User';
            const email = user.email || '';
            const avatar = user.user_metadata?.picture ||
                          user.user_metadata?.avatar_url ||
                          `https://ui-avatars.com/api/?name=${encodeURIComponent(name)}&background=667eea&color=fff`;

            console.log('Updating profile display:', { name, email, avatar });

            profileName.textContent = name;
            profileEmail.textContent = email;
            profileImage.src = avatar;
        }

        async function updateUserLogin(user) {
            // Upsert into users_login table
            const userId = user.id;
            const name = user.user_metadata?.full_name ||
                        user.user_metadata?.name ||
                        user.user_metadata?.given_name + ' ' + user.user_metadata?.family_name ||
                        user.email?.split('@')[0] ||
                        "LinkedIn User";
            const email = user.email;
            const now = new Date().toISOString();

            // Log user data for debugging
            console.log('Updating user login for:', name, email);
            console.log('User metadata:', user.user_metadata);

            // Extract LinkedIn profile data
            const avatarUrl = user.user_metadata?.picture || user.user_metadata?.avatar_url || null;

            // Get the actual LinkedIn user ID (sub field contains the real LinkedIn ID)
            const linkedinId = user.user_metadata?.sub ||
                             user.identities?.[0]?.identity_data?.sub ||
                             user.user_metadata?.provider_id || null;

            // Try to extract LinkedIn profile URL
            let profileUrl = null;

            // Check if LinkedIn provides the profile URL directly
            if (user.user_metadata?.profile_url && !user.user_metadata.profile_url.includes('oauth')) {
                profileUrl = user.user_metadata.profile_url;
            } else if (user.identities?.[0]?.identity_data?.profile_url) {
                profileUrl = user.identities[0].identity_data.profile_url;
            } else {
                // LinkedIn doesn't provide the profile username in basic OAuth
                // We'll store a search URL instead for manual lookup
                const searchName = encodeURIComponent(name);
                profileUrl = `https://www.linkedin.com/search/results/people/?keywords=${searchName}`;
            }

            // Extract location if available (LinkedIn doesn't provide location in basic scope)
            const location = user.user_metadata?.location ||
                           user.user_metadata?.country ||
                           (user.user_metadata?.locale && user.user_metadata.locale !== 'en_US' ? user.user_metadata.locale : null) ||
                           null;

            const { data, error: upsertError } = await supabaseClient
                .from("users_login")
                .upsert({
                    user_id: userId,
                    name: name,
                    email: email,
                    last_login: now,
                    profile_url: profileUrl,
                    avatar_url: avatarUrl,
                    linkedin_id: linkedinId,
                    location: location,
                    metadata: {
                        user_metadata: user.user_metadata,
                        app_metadata: user.app_metadata,
                        identities: user.identities,
                        created_at: user.created_at
                    }
                }, { onConflict: "user_id" })
                .select();

            if (upsertError) console.error("DB upsert error:", upsertError.message);

            // Increment login_count
            if (data && data[0]) {
                const loginCount = data[0]?.login_count || 0;
                await supabaseClient
                    .from("users_login")
                    .update({ login_count: loginCount + 1 })
                    .eq("user_id", userId);
            }
        }

        // Profile dropdown functionality
        document.addEventListener('DOMContentLoaded', function() {
            const profileBtn = document.getElementById('profileBtn');
            const dropdownMenu = document.getElementById('dropdownMenu');
            const logoutBtn = document.getElementById('logoutBtn');

            if (profileBtn && dropdownMenu) {
                profileBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    dropdownMenu.classList.toggle('show');
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', function() {
                    dropdownMenu.classList.remove('show');
                });

                // Prevent dropdown from closing when clicking inside
                dropdownMenu.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }

            if (logoutBtn) {
                logoutBtn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    console.log('Logout button clicked');

                    // Set a timeout to force logout if Supabase hangs
                    const forceLogoutTimer = setTimeout(() => {
                        console.log('Force logout due to timeout');
                        localStorage.clear();
                        sessionStorage.clear();
                        window.location.replace('login.html');
                    }, 3000); // 3 seconds timeout

                    try {
                        console.log('Calling supabase signOut...');
                        const result = await supabaseClient.auth.signOut();
                        console.log('SignOut result:', result);

                        clearTimeout(forceLogoutTimer);

                        if (result.error) {
                            console.error('Logout error:', result.error.message);
                        } else {
                            console.log('âœ… Supabase signOut successful');
                        }

                        // Always clear storage and redirect regardless of Supabase result
                        localStorage.clear();
                        sessionStorage.clear();
                        console.log('Redirecting to login...');
                        window.location.replace('login.html');

                    } catch (err) {
                        console.error('Logout exception:', err);
                        clearTimeout(forceLogoutTimer);
                        // Force redirect even if logout fails
                        localStorage.clear();
                        sessionStorage.clear();
                        window.location.replace('login.html');
                    }
                });
            }
        });

        // Handle authentication state changes for session timeout
        supabaseClient.auth.onAuthStateChange(async (event, session) => {
            if (event === 'SIGNED_OUT' || !session) {
                console.log('Session expired or user signed out, redirecting to login...');
                window.location.href = 'login.html';
            } else if (event === 'SIGNED_IN' && session?.user) {
                console.log('User signed in, updating profile...');
                updateUserProfile(session.user);
                await updateUserLogin(session.user);
            }
        });

        // Check session validity every 30 minutes for beta tracking
        setInterval(async () => {
            const { data: { session }, error } = await supabaseClient.auth.getSession();
            if (!session || error) {
                console.log('Session check: redirecting to login...');
                window.location.href = 'login.html';
            }
        }, 30 * 60 * 1000); // 30 minutes

        // Run on page load
        checkUser();
    </script>
</body>

</html>